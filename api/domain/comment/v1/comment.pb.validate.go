// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: domain/comment/v1/comment.proto

package commentv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Subject with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subject with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubjectMultiError, or nil if none found.
func (m *Subject) ValidateAll() error {
	return m.validate(true)
}

func (m *Subject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OwnerUid

	// no validation rules for BelongId

	// no validation rules for BizType

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for FloorCount

	// no validation rules for ReplyCount

	// no validation rules for State

	// no validation rules for Attr

	// no validation rules for Meta

	if len(errors) > 0 {
		return SubjectMultiError(errors)
	}

	return nil
}

// SubjectMultiError is an error wrapping multiple validation errors returned
// by Subject.ValidateAll() if the designated constraints aren't met.
type SubjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubjectMultiError) AllErrors() []error { return m }

// SubjectValidationError is the validation error returned by Subject.Validate
// if the designated constraints aren't met.
type SubjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubjectValidationError) ErrorName() string { return "SubjectValidationError" }

// Error satisfies the builtin error interface
func (e SubjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubjectValidationError{}

// Validate checks the field values on FloorAttr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FloorAttr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FloorAttr with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FloorAttrMultiError, or nil
// if none found.
func (m *FloorAttr) ValidateAll() error {
	return m.validate(true)
}

func (m *FloorAttr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplyCount

	// no validation rules for PinAdmin

	// no validation rules for PinOwner

	// no validation rules for Fold

	// no validation rules for Hot

	if len(errors) > 0 {
		return FloorAttrMultiError(errors)
	}

	return nil
}

// FloorAttrMultiError is an error wrapping multiple validation errors returned
// by FloorAttr.ValidateAll() if the designated constraints aren't met.
type FloorAttrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FloorAttrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FloorAttrMultiError) AllErrors() []error { return m }

// FloorAttrValidationError is the validation error returned by
// FloorAttr.Validate if the designated constraints aren't met.
type FloorAttrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FloorAttrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FloorAttrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FloorAttrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FloorAttrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FloorAttrValidationError) ErrorName() string { return "FloorAttrValidationError" }

// Error satisfies the builtin error interface
func (e FloorAttrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFloorAttr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FloorAttrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FloorAttrValidationError{}

// Validate checks the field values on Reply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Reply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Reply with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReplyMultiError, or nil if none found.
func (m *Reply) ValidateAll() error {
	return m.validate(true)
}

func (m *Reply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OwnerUid

	// no validation rules for SubjectId

	// no validation rules for BizType

	// no validation rules for FloorId

	// no validation rules for Content

	// no validation rules for AtUid

	// no validation rules for Deleted

	// no validation rules for State

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for LikeCount

	// no validation rules for DislikeCount

	// no validation rules for Dialog

	// no validation rules for FanGrade

	// no validation rules for Platform

	// no validation rules for Device

	// no validation rules for Attr

	// no validation rules for Meta

	if all {
		switch v := interface{}(m.GetFloorAttr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "FloorAttr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "FloorAttr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFloorAttr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReplyValidationError{
				field:  "FloorAttr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReplyMultiError(errors)
	}

	return nil
}

// ReplyMultiError is an error wrapping multiple validation errors returned by
// Reply.ValidateAll() if the designated constraints aren't met.
type ReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplyMultiError) AllErrors() []error { return m }

// ReplyValidationError is the validation error returned by Reply.Validate if
// the designated constraints aren't met.
type ReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplyValidationError) ErrorName() string { return "ReplyValidationError" }

// Error satisfies the builtin error interface
func (e ReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplyValidationError{}

// Validate checks the field values on Floor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Floor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Floor with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FloorMultiError, or nil if none found.
func (m *Floor) ValidateAll() error {
	return m.validate(true)
}

func (m *Floor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRootReply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "RootReply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "RootReply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootReply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FloorValidationError{
				field:  "RootReply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FloorValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FloorValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FloorValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FloorValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FloorMultiError(errors)
	}

	return nil
}

// FloorMultiError is an error wrapping multiple validation errors returned by
// Floor.ValidateAll() if the designated constraints aren't met.
type FloorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FloorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FloorMultiError) AllErrors() []error { return m }

// FloorValidationError is the validation error returned by Floor.Validate if
// the designated constraints aren't met.
type FloorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FloorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FloorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FloorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FloorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FloorValidationError) ErrorName() string { return "FloorValidationError" }

// Error satisfies the builtin error interface
func (e FloorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFloor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FloorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FloorValidationError{}

// Validate checks the field values on CreateSubjectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateSubjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubjectReqMultiError, or nil if none found.
func (m *CreateSubjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BelongId

	// no validation rules for BizType

	// no validation rules for OwnerUid

	if len(errors) > 0 {
		return CreateSubjectReqMultiError(errors)
	}

	return nil
}

// CreateSubjectReqMultiError is an error wrapping multiple validation errors
// returned by CreateSubjectReq.ValidateAll() if the designated constraints
// aren't met.
type CreateSubjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubjectReqMultiError) AllErrors() []error { return m }

// CreateSubjectReqValidationError is the validation error returned by
// CreateSubjectReq.Validate if the designated constraints aren't met.
type CreateSubjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubjectReqValidationError) ErrorName() string { return "CreateSubjectReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateSubjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubjectReqValidationError{}

// Validate checks the field values on CreateSubjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubjectResponseMultiError, or nil if none found.
func (m *CreateSubjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	if len(errors) > 0 {
		return CreateSubjectResponseMultiError(errors)
	}

	return nil
}

// CreateSubjectResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSubjectResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSubjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubjectResponseMultiError) AllErrors() []error { return m }

// CreateSubjectResponseValidationError is the validation error returned by
// CreateSubjectResponse.Validate if the designated constraints aren't met.
type CreateSubjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubjectResponseValidationError) ErrorName() string {
	return "CreateSubjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubjectResponseValidationError{}

// Validate checks the field values on GetSubjectByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByIdReqMultiError, or nil if none found.
func (m *GetSubjectByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetSubjectByIdReqMultiError(errors)
	}

	return nil
}

// GetSubjectByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetSubjectByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetSubjectByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByIdReqMultiError) AllErrors() []error { return m }

// GetSubjectByIdReqValidationError is the validation error returned by
// GetSubjectByIdReq.Validate if the designated constraints aren't met.
type GetSubjectByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByIdReqValidationError) ErrorName() string {
	return "GetSubjectByIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByIdReqValidationError{}

// Validate checks the field values on GetSubjectByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByIdResponseMultiError, or nil if none found.
func (m *GetSubjectByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubjectByIdResponseValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubjectByIdResponseValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubjectByIdResponseValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubjectByIdResponseMultiError(errors)
	}

	return nil
}

// GetSubjectByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetSubjectByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSubjectByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByIdResponseMultiError) AllErrors() []error { return m }

// GetSubjectByIdResponseValidationError is the validation error returned by
// GetSubjectByIdResponse.Validate if the designated constraints aren't met.
type GetSubjectByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByIdResponseValidationError) ErrorName() string {
	return "GetSubjectByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByIdResponseValidationError{}

// Validate checks the field values on GetSubjectByBelongReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByBelongReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByBelongReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByBelongReqMultiError, or nil if none found.
func (m *GetSubjectByBelongReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByBelongReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BelongId

	// no validation rules for BizType

	if len(errors) > 0 {
		return GetSubjectByBelongReqMultiError(errors)
	}

	return nil
}

// GetSubjectByBelongReqMultiError is an error wrapping multiple validation
// errors returned by GetSubjectByBelongReq.ValidateAll() if the designated
// constraints aren't met.
type GetSubjectByBelongReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByBelongReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByBelongReqMultiError) AllErrors() []error { return m }

// GetSubjectByBelongReqValidationError is the validation error returned by
// GetSubjectByBelongReq.Validate if the designated constraints aren't met.
type GetSubjectByBelongReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByBelongReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByBelongReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByBelongReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByBelongReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByBelongReqValidationError) ErrorName() string {
	return "GetSubjectByBelongReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByBelongReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByBelongReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByBelongReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByBelongReqValidationError{}

// Validate checks the field values on GetSubjectByBelongResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByBelongResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByBelongResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByBelongResponseMultiError, or nil if none found.
func (m *GetSubjectByBelongResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByBelongResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubjectByBelongResponseValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubjectByBelongResponseValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubjectByBelongResponseValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubjectByBelongResponseMultiError(errors)
	}

	return nil
}

// GetSubjectByBelongResponseMultiError is an error wrapping multiple
// validation errors returned by GetSubjectByBelongResponse.ValidateAll() if
// the designated constraints aren't met.
type GetSubjectByBelongResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByBelongResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByBelongResponseMultiError) AllErrors() []error { return m }

// GetSubjectByBelongResponseValidationError is the validation error returned
// by GetSubjectByBelongResponse.Validate if the designated constraints aren't met.
type GetSubjectByBelongResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByBelongResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByBelongResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByBelongResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByBelongResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByBelongResponseValidationError) ErrorName() string {
	return "GetSubjectByBelongResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByBelongResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByBelongResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByBelongResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByBelongResponseValidationError{}

// Validate checks the field values on CreateReplyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateReplyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateReplyReqMultiError,
// or nil if none found.
func (m *CreateReplyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsFloor

	// no validation rules for OwnerUid

	// no validation rules for SubjectId

	// no validation rules for BizType

	// no validation rules for FloorId

	// no validation rules for Content

	// no validation rules for AtUid

	if len(errors) > 0 {
		return CreateReplyReqMultiError(errors)
	}

	return nil
}

// CreateReplyReqMultiError is an error wrapping multiple validation errors
// returned by CreateReplyReq.ValidateAll() if the designated constraints
// aren't met.
type CreateReplyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplyReqMultiError) AllErrors() []error { return m }

// CreateReplyReqValidationError is the validation error returned by
// CreateReplyReq.Validate if the designated constraints aren't met.
type CreateReplyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplyReqValidationError) ErrorName() string { return "CreateReplyReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateReplyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplyReqValidationError{}

// Validate checks the field values on CreateReplyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReplyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateReplyResponseMultiError, or nil if none found.
func (m *CreateReplyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplyId

	if len(errors) > 0 {
		return CreateReplyResponseMultiError(errors)
	}

	return nil
}

// CreateReplyResponseMultiError is an error wrapping multiple validation
// errors returned by CreateReplyResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateReplyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplyResponseMultiError) AllErrors() []error { return m }

// CreateReplyResponseValidationError is the validation error returned by
// CreateReplyResponse.Validate if the designated constraints aren't met.
type CreateReplyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplyResponseValidationError) ErrorName() string {
	return "CreateReplyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReplyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplyResponseValidationError{}

// Validate checks the field values on GetReplyByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetReplyByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReplyByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReplyByIdReqMultiError, or nil if none found.
func (m *GetReplyByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReplyByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetReplyByIdReqMultiError(errors)
	}

	return nil
}

// GetReplyByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetReplyByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetReplyByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReplyByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReplyByIdReqMultiError) AllErrors() []error { return m }

// GetReplyByIdReqValidationError is the validation error returned by
// GetReplyByIdReq.Validate if the designated constraints aren't met.
type GetReplyByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReplyByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReplyByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReplyByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReplyByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReplyByIdReqValidationError) ErrorName() string { return "GetReplyByIdReqValidationError" }

// Error satisfies the builtin error interface
func (e GetReplyByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReplyByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReplyByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReplyByIdReqValidationError{}

// Validate checks the field values on GetReplyByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReplyByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReplyByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReplyByIdResponseMultiError, or nil if none found.
func (m *GetReplyByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReplyByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReplyByIdResponseValidationError{
					field:  "Reply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReplyByIdResponseValidationError{
					field:  "Reply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReplyByIdResponseValidationError{
				field:  "Reply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReplyByIdResponseMultiError(errors)
	}

	return nil
}

// GetReplyByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetReplyByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetReplyByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReplyByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReplyByIdResponseMultiError) AllErrors() []error { return m }

// GetReplyByIdResponseValidationError is the validation error returned by
// GetReplyByIdResponse.Validate if the designated constraints aren't met.
type GetReplyByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReplyByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReplyByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReplyByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReplyByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReplyByIdResponseValidationError) ErrorName() string {
	return "GetReplyByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReplyByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReplyByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReplyByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReplyByIdResponseValidationError{}

// Validate checks the field values on ListReplyByIdsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByIdsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByIdsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReplyByIdsReqMultiError, or nil if none found.
func (m *ListReplyByIdsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByIdsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListReplyByIdsReqMultiError(errors)
	}

	return nil
}

// ListReplyByIdsReqMultiError is an error wrapping multiple validation errors
// returned by ListReplyByIdsReq.ValidateAll() if the designated constraints
// aren't met.
type ListReplyByIdsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByIdsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByIdsReqMultiError) AllErrors() []error { return m }

// ListReplyByIdsReqValidationError is the validation error returned by
// ListReplyByIdsReq.Validate if the designated constraints aren't met.
type ListReplyByIdsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByIdsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByIdsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByIdsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByIdsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByIdsReqValidationError) ErrorName() string {
	return "ListReplyByIdsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByIdsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByIdsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByIdsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByIdsReqValidationError{}

// Validate checks the field values on ListReplyByIdsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByIdsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByIdsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReplyByIdsResponseMultiError, or nil if none found.
func (m *ListReplyByIdsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByIdsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReplyByIdsResponseValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReplyByIdsResponseValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReplyByIdsResponseValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListReplyByIdsResponseMultiError(errors)
	}

	return nil
}

// ListReplyByIdsResponseMultiError is an error wrapping multiple validation
// errors returned by ListReplyByIdsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReplyByIdsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByIdsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByIdsResponseMultiError) AllErrors() []error { return m }

// ListReplyByIdsResponseValidationError is the validation error returned by
// ListReplyByIdsResponse.Validate if the designated constraints aren't met.
type ListReplyByIdsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByIdsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByIdsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByIdsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByIdsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByIdsResponseValidationError) ErrorName() string {
	return "ListReplyByIdsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByIdsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByIdsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByIdsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByIdsResponseValidationError{}

// Validate checks the field values on DialogReplys with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DialogReplys) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DialogReplys with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DialogReplysMultiError, or
// nil if none found.
func (m *DialogReplys) ValidateAll() error {
	return m.validate(true)
}

func (m *DialogReplys) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DialogReplysValidationError{
					field:  "Root",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DialogReplysValidationError{
					field:  "Root",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DialogReplysValidationError{
				field:  "Root",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DialogReplysValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DialogReplysValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DialogReplysValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return DialogReplysMultiError(errors)
	}

	return nil
}

// DialogReplysMultiError is an error wrapping multiple validation errors
// returned by DialogReplys.ValidateAll() if the designated constraints aren't met.
type DialogReplysMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DialogReplysMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DialogReplysMultiError) AllErrors() []error { return m }

// DialogReplysValidationError is the validation error returned by
// DialogReplys.Validate if the designated constraints aren't met.
type DialogReplysValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DialogReplysValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DialogReplysValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DialogReplysValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DialogReplysValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DialogReplysValidationError) ErrorName() string { return "DialogReplysValidationError" }

// Error satisfies the builtin error interface
func (e DialogReplysValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDialogReplys.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DialogReplysValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DialogReplysValidationError{}

// Validate checks the field values on ListFloorBySubjectSortReplyReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListFloorBySubjectSortReplyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectSortReplyReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectSortReplyReqMultiError, or nil if none found.
func (m *ListFloorBySubjectSortReplyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectSortReplyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubjectId() <= 1 {
		err := ListFloorBySubjectSortReplyReqValidationError{
			field:  "SubjectId",
			reason: "value must be greater than 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectSortReplyReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectSortReplyReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectSortReplyReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectSortReplyReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectSortReplyReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectSortReplyReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectSortReplyReqMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectSortReplyReqMultiError is an error wrapping multiple
// validation errors returned by ListFloorBySubjectSortReplyReq.ValidateAll()
// if the designated constraints aren't met.
type ListFloorBySubjectSortReplyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectSortReplyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectSortReplyReqMultiError) AllErrors() []error { return m }

// ListFloorBySubjectSortReplyReqValidationError is the validation error
// returned by ListFloorBySubjectSortReplyReq.Validate if the designated
// constraints aren't met.
type ListFloorBySubjectSortReplyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectSortReplyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectSortReplyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectSortReplyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectSortReplyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectSortReplyReqValidationError) ErrorName() string {
	return "ListFloorBySubjectSortReplyReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectSortReplyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectSortReplyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectSortReplyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectSortReplyReqValidationError{}

// Validate checks the field values on ListFloorBySubjectSortReplyResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListFloorBySubjectSortReplyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectSortReplyResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectSortReplyResponseMultiError, or nil if none found.
func (m *ListFloorBySubjectSortReplyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectSortReplyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFloors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFloorBySubjectSortReplyResponseValidationError{
						field:  fmt.Sprintf("Floors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFloorBySubjectSortReplyResponseValidationError{
						field:  fmt.Sprintf("Floors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFloorBySubjectSortReplyResponseValidationError{
					field:  fmt.Sprintf("Floors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectSortReplyResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectSortReplyResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectSortReplyResponseValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectSortReplyResponseMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectSortReplyResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListFloorBySubjectSortReplyResponse.ValidateAll() if the designated
// constraints aren't met.
type ListFloorBySubjectSortReplyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectSortReplyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectSortReplyResponseMultiError) AllErrors() []error { return m }

// ListFloorBySubjectSortReplyResponseValidationError is the validation error
// returned by ListFloorBySubjectSortReplyResponse.Validate if the designated
// constraints aren't met.
type ListFloorBySubjectSortReplyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectSortReplyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectSortReplyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectSortReplyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectSortReplyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectSortReplyResponseValidationError) ErrorName() string {
	return "ListFloorBySubjectSortReplyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectSortReplyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectSortReplyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectSortReplyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectSortReplyResponseValidationError{}

// Validate checks the field values on ListFloorBySubjectSortTimeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListFloorBySubjectSortTimeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectSortTimeReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectSortTimeReqMultiError, or nil if none found.
func (m *ListFloorBySubjectSortTimeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectSortTimeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubjectId() <= 1 {
		err := ListFloorBySubjectSortTimeReqValidationError{
			field:  "SubjectId",
			reason: "value must be greater than 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectSortTimeReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectSortTimeReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectSortTimeReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectSortTimeReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectSortTimeReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectSortTimeReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectSortTimeReqMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectSortTimeReqMultiError is an error wrapping multiple
// validation errors returned by ListFloorBySubjectSortTimeReq.ValidateAll()
// if the designated constraints aren't met.
type ListFloorBySubjectSortTimeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectSortTimeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectSortTimeReqMultiError) AllErrors() []error { return m }

// ListFloorBySubjectSortTimeReqValidationError is the validation error
// returned by ListFloorBySubjectSortTimeReq.Validate if the designated
// constraints aren't met.
type ListFloorBySubjectSortTimeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectSortTimeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectSortTimeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectSortTimeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectSortTimeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectSortTimeReqValidationError) ErrorName() string {
	return "ListFloorBySubjectSortTimeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectSortTimeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectSortTimeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectSortTimeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectSortTimeReqValidationError{}

// Validate checks the field values on ListFloorBySubjectSortTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListFloorBySubjectSortTimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectSortTimeResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectSortTimeResponseMultiError, or nil if none found.
func (m *ListFloorBySubjectSortTimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectSortTimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFloors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFloorBySubjectSortTimeResponseValidationError{
						field:  fmt.Sprintf("Floors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFloorBySubjectSortTimeResponseValidationError{
						field:  fmt.Sprintf("Floors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFloorBySubjectSortTimeResponseValidationError{
					field:  fmt.Sprintf("Floors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectSortTimeResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectSortTimeResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectSortTimeResponseValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectSortTimeResponseMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectSortTimeResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListFloorBySubjectSortTimeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListFloorBySubjectSortTimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectSortTimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectSortTimeResponseMultiError) AllErrors() []error { return m }

// ListFloorBySubjectSortTimeResponseValidationError is the validation error
// returned by ListFloorBySubjectSortTimeResponse.Validate if the designated
// constraints aren't met.
type ListFloorBySubjectSortTimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectSortTimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectSortTimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectSortTimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectSortTimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectSortTimeResponseValidationError) ErrorName() string {
	return "ListFloorBySubjectSortTimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectSortTimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectSortTimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectSortTimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectSortTimeResponseValidationError{}

// Validate checks the field values on ListReplyByFloorSortLikeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByFloorSortLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorSortLikeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReplyByFloorSortLikeReqMultiError, or nil if none found.
func (m *ListReplyByFloorSortLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorSortLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	if m.GetFloorId() <= 0 {
		err := ListReplyByFloorSortLikeReqValidationError{
			field:  "FloorId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorSortLikeReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorSortLikeReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorSortLikeReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorSortLikeReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorSortLikeReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorSortLikeReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorSortLikeReqMultiError(errors)
	}

	return nil
}

// ListReplyByFloorSortLikeReqMultiError is an error wrapping multiple
// validation errors returned by ListReplyByFloorSortLikeReq.ValidateAll() if
// the designated constraints aren't met.
type ListReplyByFloorSortLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorSortLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorSortLikeReqMultiError) AllErrors() []error { return m }

// ListReplyByFloorSortLikeReqValidationError is the validation error returned
// by ListReplyByFloorSortLikeReq.Validate if the designated constraints
// aren't met.
type ListReplyByFloorSortLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorSortLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorSortLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorSortLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorSortLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorSortLikeReqValidationError) ErrorName() string {
	return "ListReplyByFloorSortLikeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorSortLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorSortLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorSortLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorSortLikeReqValidationError{}

// Validate checks the field values on ListReplyByFloorSortLikeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListReplyByFloorSortLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorSortLikeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListReplyByFloorSortLikeResponseMultiError, or nil if none found.
func (m *ListReplyByFloorSortLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorSortLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReplyByFloorSortLikeResponseValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReplyByFloorSortLikeResponseValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReplyByFloorSortLikeResponseValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorSortLikeResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorSortLikeResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorSortLikeResponseValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorSortLikeResponseMultiError(errors)
	}

	return nil
}

// ListReplyByFloorSortLikeResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListReplyByFloorSortLikeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReplyByFloorSortLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorSortLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorSortLikeResponseMultiError) AllErrors() []error { return m }

// ListReplyByFloorSortLikeResponseValidationError is the validation error
// returned by ListReplyByFloorSortLikeResponse.Validate if the designated
// constraints aren't met.
type ListReplyByFloorSortLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorSortLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorSortLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorSortLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorSortLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorSortLikeResponseValidationError) ErrorName() string {
	return "ListReplyByFloorSortLikeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorSortLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorSortLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorSortLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorSortLikeResponseValidationError{}

// Validate checks the field values on ListReplyByFloorSortTimeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByFloorSortTimeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorSortTimeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReplyByFloorSortTimeReqMultiError, or nil if none found.
func (m *ListReplyByFloorSortTimeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorSortTimeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	if m.GetFloorId() <= 0 {
		err := ListReplyByFloorSortTimeReqValidationError{
			field:  "FloorId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorSortTimeReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorSortTimeReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorSortTimeReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorSortTimeReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorSortTimeReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorSortTimeReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorSortTimeReqMultiError(errors)
	}

	return nil
}

// ListReplyByFloorSortTimeReqMultiError is an error wrapping multiple
// validation errors returned by ListReplyByFloorSortTimeReq.ValidateAll() if
// the designated constraints aren't met.
type ListReplyByFloorSortTimeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorSortTimeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorSortTimeReqMultiError) AllErrors() []error { return m }

// ListReplyByFloorSortTimeReqValidationError is the validation error returned
// by ListReplyByFloorSortTimeReq.Validate if the designated constraints
// aren't met.
type ListReplyByFloorSortTimeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorSortTimeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorSortTimeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorSortTimeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorSortTimeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorSortTimeReqValidationError) ErrorName() string {
	return "ListReplyByFloorSortTimeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorSortTimeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorSortTimeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorSortTimeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorSortTimeReqValidationError{}

// Validate checks the field values on ListReplyByFloorSortTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListReplyByFloorSortTimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorSortTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListReplyByFloorSortTimeResponseMultiError, or nil if none found.
func (m *ListReplyByFloorSortTimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorSortTimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReplyByFloorSortTimeResponseValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReplyByFloorSortTimeResponseValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReplyByFloorSortTimeResponseValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorSortTimeResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorSortTimeResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorSortTimeResponseValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorSortTimeResponseMultiError(errors)
	}

	return nil
}

// ListReplyByFloorSortTimeResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListReplyByFloorSortTimeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReplyByFloorSortTimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorSortTimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorSortTimeResponseMultiError) AllErrors() []error { return m }

// ListReplyByFloorSortTimeResponseValidationError is the validation error
// returned by ListReplyByFloorSortTimeResponse.Validate if the designated
// constraints aren't met.
type ListReplyByFloorSortTimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorSortTimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorSortTimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorSortTimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorSortTimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorSortTimeResponseValidationError) ErrorName() string {
	return "ListReplyByFloorSortTimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorSortTimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorSortTimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorSortTimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorSortTimeResponseValidationError{}

// Validate checks the field values on DialogPageReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DialogPageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DialogPageReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DialogPageReqMultiError, or
// nil if none found.
func (m *DialogPageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DialogPageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 1 {
		err := DialogPageReqValidationError{
			field:  "Id",
			reason: "value must be greater than 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Order

	// no validation rules for Plat

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return DialogPageReqMultiError(errors)
	}

	return nil
}

// DialogPageReqMultiError is an error wrapping multiple validation errors
// returned by DialogPageReq.ValidateAll() if the designated constraints
// aren't met.
type DialogPageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DialogPageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DialogPageReqMultiError) AllErrors() []error { return m }

// DialogPageReqValidationError is the validation error returned by
// DialogPageReq.Validate if the designated constraints aren't met.
type DialogPageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DialogPageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DialogPageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DialogPageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DialogPageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DialogPageReqValidationError) ErrorName() string { return "DialogPageReqValidationError" }

// Error satisfies the builtin error interface
func (e DialogPageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDialogPageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DialogPageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DialogPageReqValidationError{}

// Validate checks the field values on DialogCursorReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DialogCursorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DialogCursorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DialogCursorReqMultiError, or nil if none found.
func (m *DialogCursorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DialogCursorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOid() <= 1 {
		err := DialogCursorReqValidationError{
			field:  "Oid",
			reason: "value must be greater than 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Sid

	// no validation rules for Bid

	// no validation rules for Order

	// no validation rules for Plat

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return DialogCursorReqMultiError(errors)
	}

	return nil
}

// DialogCursorReqMultiError is an error wrapping multiple validation errors
// returned by DialogCursorReq.ValidateAll() if the designated constraints
// aren't met.
type DialogCursorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DialogCursorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DialogCursorReqMultiError) AllErrors() []error { return m }

// DialogCursorReqValidationError is the validation error returned by
// DialogCursorReq.Validate if the designated constraints aren't met.
type DialogCursorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DialogCursorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DialogCursorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DialogCursorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DialogCursorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DialogCursorReqValidationError) ErrorName() string { return "DialogCursorReqValidationError" }

// Error satisfies the builtin error interface
func (e DialogCursorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDialogCursorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DialogCursorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DialogCursorReqValidationError{}

// Validate checks the field values on DialogReplysReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DialogReplysReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DialogReplysReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DialogReplysReplyMultiError, or nil if none found.
func (m *DialogReplysReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DialogReplysReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DialogReplysReplyValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DialogReplysReplyValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DialogReplysReplyValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return DialogReplysReplyMultiError(errors)
	}

	return nil
}

// DialogReplysReplyMultiError is an error wrapping multiple validation errors
// returned by DialogReplysReply.ValidateAll() if the designated constraints
// aren't met.
type DialogReplysReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DialogReplysReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DialogReplysReplyMultiError) AllErrors() []error { return m }

// DialogReplysReplyValidationError is the validation error returned by
// DialogReplysReply.Validate if the designated constraints aren't met.
type DialogReplysReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DialogReplysReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DialogReplysReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DialogReplysReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DialogReplysReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DialogReplysReplyValidationError) ErrorName() string {
	return "DialogReplysReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DialogReplysReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDialogReplysReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DialogReplysReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DialogReplysReplyValidationError{}

// Validate checks the field values on AddLikeReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddLikeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddLikeReqMultiError, or
// nil if none found.
func (m *AddLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplyId

	// no validation rules for Uid

	if len(errors) > 0 {
		return AddLikeReqMultiError(errors)
	}

	return nil
}

// AddLikeReqMultiError is an error wrapping multiple validation errors
// returned by AddLikeReq.ValidateAll() if the designated constraints aren't met.
type AddLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddLikeReqMultiError) AllErrors() []error { return m }

// AddLikeReqValidationError is the validation error returned by
// AddLikeReq.Validate if the designated constraints aren't met.
type AddLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddLikeReqValidationError) ErrorName() string { return "AddLikeReqValidationError" }

// Error satisfies the builtin error interface
func (e AddLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddLikeReqValidationError{}

// Validate checks the field values on AddLikeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddLikeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddLikeResponseMultiError, or nil if none found.
func (m *AddLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddLikeResponseMultiError(errors)
	}

	return nil
}

// AddLikeResponseMultiError is an error wrapping multiple validation errors
// returned by AddLikeResponse.ValidateAll() if the designated constraints
// aren't met.
type AddLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddLikeResponseMultiError) AllErrors() []error { return m }

// AddLikeResponseValidationError is the validation error returned by
// AddLikeResponse.Validate if the designated constraints aren't met.
type AddLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddLikeResponseValidationError) ErrorName() string { return "AddLikeResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddLikeResponseValidationError{}

// Validate checks the field values on CancelLikeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CancelLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLikeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CancelLikeReqMultiError, or
// nil if none found.
func (m *CancelLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplyId

	// no validation rules for Uid

	if len(errors) > 0 {
		return CancelLikeReqMultiError(errors)
	}

	return nil
}

// CancelLikeReqMultiError is an error wrapping multiple validation errors
// returned by CancelLikeReq.ValidateAll() if the designated constraints
// aren't met.
type CancelLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLikeReqMultiError) AllErrors() []error { return m }

// CancelLikeReqValidationError is the validation error returned by
// CancelLikeReq.Validate if the designated constraints aren't met.
type CancelLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLikeReqValidationError) ErrorName() string { return "CancelLikeReqValidationError" }

// Error satisfies the builtin error interface
func (e CancelLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLikeReqValidationError{}

// Validate checks the field values on CancelLikeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLikeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLikeResponseMultiError, or nil if none found.
func (m *CancelLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CancelLikeResponseMultiError(errors)
	}

	return nil
}

// CancelLikeResponseMultiError is an error wrapping multiple validation errors
// returned by CancelLikeResponse.ValidateAll() if the designated constraints
// aren't met.
type CancelLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLikeResponseMultiError) AllErrors() []error { return m }

// CancelLikeResponseValidationError is the validation error returned by
// CancelLikeResponse.Validate if the designated constraints aren't met.
type CancelLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLikeResponseValidationError) ErrorName() string {
	return "CancelLikeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLikeResponseValidationError{}

// Validate checks the field values on IsLikeReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IsLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsLikeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IsLikeReqMultiError, or nil
// if none found.
func (m *IsLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *IsLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplyId

	// no validation rules for Uid

	if len(errors) > 0 {
		return IsLikeReqMultiError(errors)
	}

	return nil
}

// IsLikeReqMultiError is an error wrapping multiple validation errors returned
// by IsLikeReq.ValidateAll() if the designated constraints aren't met.
type IsLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsLikeReqMultiError) AllErrors() []error { return m }

// IsLikeReqValidationError is the validation error returned by
// IsLikeReq.Validate if the designated constraints aren't met.
type IsLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsLikeReqValidationError) ErrorName() string { return "IsLikeReqValidationError" }

// Error satisfies the builtin error interface
func (e IsLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsLikeReqValidationError{}

// Validate checks the field values on IsLikeResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IsLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsLikeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IsLikeResponseMultiError,
// or nil if none found.
func (m *IsLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return IsLikeResponseMultiError(errors)
	}

	return nil
}

// IsLikeResponseMultiError is an error wrapping multiple validation errors
// returned by IsLikeResponse.ValidateAll() if the designated constraints
// aren't met.
type IsLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsLikeResponseMultiError) AllErrors() []error { return m }

// IsLikeResponseValidationError is the validation error returned by
// IsLikeResponse.Validate if the designated constraints aren't met.
type IsLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsLikeResponseValidationError) ErrorName() string { return "IsLikeResponseValidationError" }

// Error satisfies the builtin error interface
func (e IsLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsLikeResponseValidationError{}
