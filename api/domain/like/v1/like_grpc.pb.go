// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package likev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LikeClient is the client API for Like service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LikeClient interface {
	//  like read
	Like(ctx context.Context, in *LikeReq, opts ...grpc.CallOption) (*LikeReply, error)
	Likes(ctx context.Context, in *LikesReq, opts ...grpc.CallOption) (*LikesReply, error)
	SubjectLikes(ctx context.Context, in *SubjectLikesReq, opts ...grpc.CallOption) (*SubjectLikesReply, error)
	UserLikes(ctx context.Context, in *UserLikesReq, opts ...grpc.CallOption) (*UserLikesReply, error)
	CountObjectLike(ctx context.Context, in *CountObjectLikeReq, opts ...grpc.CallOption) (*CountObjectLikeReply, error)
	CountUserLike(ctx context.Context, in *CountUserLikeReq, opts ...grpc.CallOption) (*CountUserLikeReply, error)
	CountSubjectLike(ctx context.Context, in *CountSubjectLikeReq, opts ...grpc.CallOption) (*CountSubjectLikeReply, error)
	//  like write
	AddLike(ctx context.Context, in *AddLikeReq, opts ...grpc.CallOption) (*AddLikeReply, error)
	CancelLike(ctx context.Context, in *CancelLikeReq, opts ...grpc.CallOption) (*CancelLikeReply, error)
	// dislike read
	Dislike(ctx context.Context, in *DislikeReq, opts ...grpc.CallOption) (*DislikeReply, error)
	Dislikes(ctx context.Context, in *DislikesReq, opts ...grpc.CallOption) (*DislikesReply, error)
	SubjectDisikes(ctx context.Context, in *SubjectLikesReq, opts ...grpc.CallOption) (*SubjectDislikesReply, error)
	UserDislikes(ctx context.Context, in *UserDislikesReq, opts ...grpc.CallOption) (*UserDislikesReply, error)
	CountObjectDislike(ctx context.Context, in *CountObjectDislikeReq, opts ...grpc.CallOption) (*CountObjectDislikeReply, error)
	CountUserDislike(ctx context.Context, in *CountUserDislikeReq, opts ...grpc.CallOption) (*CountUserDislikeReply, error)
	CountSubjectDislike(ctx context.Context, in *CountSubjectDislikeReq, opts ...grpc.CallOption) (*CountSubjectDislikeReply, error)
	//  dislike write
	AddDislike(ctx context.Context, in *AddDislikeReq, opts ...grpc.CallOption) (*AddDislikeReply, error)
	CancelDislike(ctx context.Context, in *CancelLikeReq, opts ...grpc.CallOption) (*CancelDislikeReply, error)
}

type likeClient struct {
	cc grpc.ClientConnInterface
}

func NewLikeClient(cc grpc.ClientConnInterface) LikeClient {
	return &likeClient{cc}
}

func (c *likeClient) Like(ctx context.Context, in *LikeReq, opts ...grpc.CallOption) (*LikeReply, error) {
	out := new(LikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/Like", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) Likes(ctx context.Context, in *LikesReq, opts ...grpc.CallOption) (*LikesReply, error) {
	out := new(LikesReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/Likes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) SubjectLikes(ctx context.Context, in *SubjectLikesReq, opts ...grpc.CallOption) (*SubjectLikesReply, error) {
	out := new(SubjectLikesReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/SubjectLikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) UserLikes(ctx context.Context, in *UserLikesReq, opts ...grpc.CallOption) (*UserLikesReply, error) {
	out := new(UserLikesReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/UserLikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CountObjectLike(ctx context.Context, in *CountObjectLikeReq, opts ...grpc.CallOption) (*CountObjectLikeReply, error) {
	out := new(CountObjectLikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CountObjectLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CountUserLike(ctx context.Context, in *CountUserLikeReq, opts ...grpc.CallOption) (*CountUserLikeReply, error) {
	out := new(CountUserLikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CountUserLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CountSubjectLike(ctx context.Context, in *CountSubjectLikeReq, opts ...grpc.CallOption) (*CountSubjectLikeReply, error) {
	out := new(CountSubjectLikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CountSubjectLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) AddLike(ctx context.Context, in *AddLikeReq, opts ...grpc.CallOption) (*AddLikeReply, error) {
	out := new(AddLikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/AddLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CancelLike(ctx context.Context, in *CancelLikeReq, opts ...grpc.CallOption) (*CancelLikeReply, error) {
	out := new(CancelLikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CancelLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) Dislike(ctx context.Context, in *DislikeReq, opts ...grpc.CallOption) (*DislikeReply, error) {
	out := new(DislikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/Dislike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) Dislikes(ctx context.Context, in *DislikesReq, opts ...grpc.CallOption) (*DislikesReply, error) {
	out := new(DislikesReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/Dislikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) SubjectDisikes(ctx context.Context, in *SubjectLikesReq, opts ...grpc.CallOption) (*SubjectDislikesReply, error) {
	out := new(SubjectDislikesReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/SubjectDisikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) UserDislikes(ctx context.Context, in *UserDislikesReq, opts ...grpc.CallOption) (*UserDislikesReply, error) {
	out := new(UserDislikesReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/UserDislikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CountObjectDislike(ctx context.Context, in *CountObjectDislikeReq, opts ...grpc.CallOption) (*CountObjectDislikeReply, error) {
	out := new(CountObjectDislikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CountObjectDislike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CountUserDislike(ctx context.Context, in *CountUserDislikeReq, opts ...grpc.CallOption) (*CountUserDislikeReply, error) {
	out := new(CountUserDislikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CountUserDislike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CountSubjectDislike(ctx context.Context, in *CountSubjectDislikeReq, opts ...grpc.CallOption) (*CountSubjectDislikeReply, error) {
	out := new(CountSubjectDislikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CountSubjectDislike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) AddDislike(ctx context.Context, in *AddDislikeReq, opts ...grpc.CallOption) (*AddDislikeReply, error) {
	out := new(AddDislikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/AddDislike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeClient) CancelDislike(ctx context.Context, in *CancelLikeReq, opts ...grpc.CallOption) (*CancelDislikeReply, error) {
	out := new(CancelDislikeReply)
	err := c.cc.Invoke(ctx, "/domain.like.v1.Like/CancelDislike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LikeServer is the server API for Like service.
// All implementations must embed UnimplementedLikeServer
// for forward compatibility
type LikeServer interface {
	//  like read
	Like(context.Context, *LikeReq) (*LikeReply, error)
	Likes(context.Context, *LikesReq) (*LikesReply, error)
	SubjectLikes(context.Context, *SubjectLikesReq) (*SubjectLikesReply, error)
	UserLikes(context.Context, *UserLikesReq) (*UserLikesReply, error)
	CountObjectLike(context.Context, *CountObjectLikeReq) (*CountObjectLikeReply, error)
	CountUserLike(context.Context, *CountUserLikeReq) (*CountUserLikeReply, error)
	CountSubjectLike(context.Context, *CountSubjectLikeReq) (*CountSubjectLikeReply, error)
	//  like write
	AddLike(context.Context, *AddLikeReq) (*AddLikeReply, error)
	CancelLike(context.Context, *CancelLikeReq) (*CancelLikeReply, error)
	// dislike read
	Dislike(context.Context, *DislikeReq) (*DislikeReply, error)
	Dislikes(context.Context, *DislikesReq) (*DislikesReply, error)
	SubjectDisikes(context.Context, *SubjectLikesReq) (*SubjectDislikesReply, error)
	UserDislikes(context.Context, *UserDislikesReq) (*UserDislikesReply, error)
	CountObjectDislike(context.Context, *CountObjectDislikeReq) (*CountObjectDislikeReply, error)
	CountUserDislike(context.Context, *CountUserDislikeReq) (*CountUserDislikeReply, error)
	CountSubjectDislike(context.Context, *CountSubjectDislikeReq) (*CountSubjectDislikeReply, error)
	//  dislike write
	AddDislike(context.Context, *AddDislikeReq) (*AddDislikeReply, error)
	CancelDislike(context.Context, *CancelLikeReq) (*CancelDislikeReply, error)
	mustEmbedUnimplementedLikeServer()
}

// UnimplementedLikeServer must be embedded to have forward compatible implementations.
type UnimplementedLikeServer struct {
}

func (UnimplementedLikeServer) Like(context.Context, *LikeReq) (*LikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Like not implemented")
}
func (UnimplementedLikeServer) Likes(context.Context, *LikesReq) (*LikesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Likes not implemented")
}
func (UnimplementedLikeServer) SubjectLikes(context.Context, *SubjectLikesReq) (*SubjectLikesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubjectLikes not implemented")
}
func (UnimplementedLikeServer) UserLikes(context.Context, *UserLikesReq) (*UserLikesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLikes not implemented")
}
func (UnimplementedLikeServer) CountObjectLike(context.Context, *CountObjectLikeReq) (*CountObjectLikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountObjectLike not implemented")
}
func (UnimplementedLikeServer) CountUserLike(context.Context, *CountUserLikeReq) (*CountUserLikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountUserLike not implemented")
}
func (UnimplementedLikeServer) CountSubjectLike(context.Context, *CountSubjectLikeReq) (*CountSubjectLikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountSubjectLike not implemented")
}
func (UnimplementedLikeServer) AddLike(context.Context, *AddLikeReq) (*AddLikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLike not implemented")
}
func (UnimplementedLikeServer) CancelLike(context.Context, *CancelLikeReq) (*CancelLikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelLike not implemented")
}
func (UnimplementedLikeServer) Dislike(context.Context, *DislikeReq) (*DislikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dislike not implemented")
}
func (UnimplementedLikeServer) Dislikes(context.Context, *DislikesReq) (*DislikesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dislikes not implemented")
}
func (UnimplementedLikeServer) SubjectDisikes(context.Context, *SubjectLikesReq) (*SubjectDislikesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubjectDisikes not implemented")
}
func (UnimplementedLikeServer) UserDislikes(context.Context, *UserDislikesReq) (*UserDislikesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDislikes not implemented")
}
func (UnimplementedLikeServer) CountObjectDislike(context.Context, *CountObjectDislikeReq) (*CountObjectDislikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountObjectDislike not implemented")
}
func (UnimplementedLikeServer) CountUserDislike(context.Context, *CountUserDislikeReq) (*CountUserDislikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountUserDislike not implemented")
}
func (UnimplementedLikeServer) CountSubjectDislike(context.Context, *CountSubjectDislikeReq) (*CountSubjectDislikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountSubjectDislike not implemented")
}
func (UnimplementedLikeServer) AddDislike(context.Context, *AddDislikeReq) (*AddDislikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDislike not implemented")
}
func (UnimplementedLikeServer) CancelDislike(context.Context, *CancelLikeReq) (*CancelDislikeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelDislike not implemented")
}
func (UnimplementedLikeServer) mustEmbedUnimplementedLikeServer() {}

// UnsafeLikeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LikeServer will
// result in compilation errors.
type UnsafeLikeServer interface {
	mustEmbedUnimplementedLikeServer()
}

func RegisterLikeServer(s grpc.ServiceRegistrar, srv LikeServer) {
	s.RegisterService(&Like_ServiceDesc, srv)
}

func _Like_Like_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).Like(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/Like",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).Like(ctx, req.(*LikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_Likes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LikesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).Likes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/Likes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).Likes(ctx, req.(*LikesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_SubjectLikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubjectLikesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).SubjectLikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/SubjectLikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).SubjectLikes(ctx, req.(*SubjectLikesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_UserLikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLikesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).UserLikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/UserLikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).UserLikes(ctx, req.(*UserLikesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CountObjectLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountObjectLikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CountObjectLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CountObjectLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CountObjectLike(ctx, req.(*CountObjectLikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CountUserLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountUserLikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CountUserLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CountUserLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CountUserLike(ctx, req.(*CountUserLikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CountSubjectLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountSubjectLikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CountSubjectLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CountSubjectLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CountSubjectLike(ctx, req.(*CountSubjectLikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_AddLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).AddLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/AddLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).AddLike(ctx, req.(*AddLikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CancelLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelLikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CancelLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CancelLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CancelLike(ctx, req.(*CancelLikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_Dislike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DislikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).Dislike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/Dislike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).Dislike(ctx, req.(*DislikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_Dislikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DislikesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).Dislikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/Dislikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).Dislikes(ctx, req.(*DislikesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_SubjectDisikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubjectLikesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).SubjectDisikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/SubjectDisikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).SubjectDisikes(ctx, req.(*SubjectLikesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_UserDislikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDislikesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).UserDislikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/UserDislikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).UserDislikes(ctx, req.(*UserDislikesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CountObjectDislike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountObjectDislikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CountObjectDislike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CountObjectDislike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CountObjectDislike(ctx, req.(*CountObjectDislikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CountUserDislike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountUserDislikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CountUserDislike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CountUserDislike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CountUserDislike(ctx, req.(*CountUserDislikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CountSubjectDislike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountSubjectDislikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CountSubjectDislike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CountSubjectDislike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CountSubjectDislike(ctx, req.(*CountSubjectDislikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_AddDislike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDislikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).AddDislike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/AddDislike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).AddDislike(ctx, req.(*AddDislikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Like_CancelDislike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelLikeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeServer).CancelDislike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/domain.like.v1.Like/CancelDislike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeServer).CancelDislike(ctx, req.(*CancelLikeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Like_ServiceDesc is the grpc.ServiceDesc for Like service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Like_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "domain.like.v1.Like",
	HandlerType: (*LikeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Like",
			Handler:    _Like_Like_Handler,
		},
		{
			MethodName: "Likes",
			Handler:    _Like_Likes_Handler,
		},
		{
			MethodName: "SubjectLikes",
			Handler:    _Like_SubjectLikes_Handler,
		},
		{
			MethodName: "UserLikes",
			Handler:    _Like_UserLikes_Handler,
		},
		{
			MethodName: "CountObjectLike",
			Handler:    _Like_CountObjectLike_Handler,
		},
		{
			MethodName: "CountUserLike",
			Handler:    _Like_CountUserLike_Handler,
		},
		{
			MethodName: "CountSubjectLike",
			Handler:    _Like_CountSubjectLike_Handler,
		},
		{
			MethodName: "AddLike",
			Handler:    _Like_AddLike_Handler,
		},
		{
			MethodName: "CancelLike",
			Handler:    _Like_CancelLike_Handler,
		},
		{
			MethodName: "Dislike",
			Handler:    _Like_Dislike_Handler,
		},
		{
			MethodName: "Dislikes",
			Handler:    _Like_Dislikes_Handler,
		},
		{
			MethodName: "SubjectDisikes",
			Handler:    _Like_SubjectDisikes_Handler,
		},
		{
			MethodName: "UserDislikes",
			Handler:    _Like_UserDislikes_Handler,
		},
		{
			MethodName: "CountObjectDislike",
			Handler:    _Like_CountObjectDislike_Handler,
		},
		{
			MethodName: "CountUserDislike",
			Handler:    _Like_CountUserDislike_Handler,
		},
		{
			MethodName: "CountSubjectDislike",
			Handler:    _Like_CountSubjectDislike_Handler,
		},
		{
			MethodName: "AddDislike",
			Handler:    _Like_AddDislike_Handler,
		},
		{
			MethodName: "CancelDislike",
			Handler:    _Like_CancelDislike_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "domain/like/v1/like.proto",
}
