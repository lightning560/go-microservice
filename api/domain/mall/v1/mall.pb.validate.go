// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: domain/mall/v1/mall.proto

package domainmallv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Shop with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Shop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Shop with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ShopMultiError, or nil if none found.
func (m *Shop) ValidateAll() error {
	return m.validate(true)
}

func (m *Shop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ShopValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Sign

	if all {
		switch v := interface{}(m.GetLogo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShopValidationError{
					field:  "Logo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShopValidationError{
					field:  "Logo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShopValidationError{
				field:  "Logo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return ShopMultiError(errors)
	}

	return nil
}

// ShopMultiError is an error wrapping multiple validation errors returned by
// Shop.ValidateAll() if the designated constraints aren't met.
type ShopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShopMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShopMultiError) AllErrors() []error { return m }

// ShopValidationError is the validation error returned by Shop.Validate if the
// designated constraints aren't met.
type ShopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShopValidationError) ErrorName() string { return "ShopValidationError" }

// Error satisfies the builtin error interface
func (e ShopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShopValidationError{}

// Validate checks the field values on Product with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Product) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Product with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProductMultiError, or nil if none found.
func (m *Product) ValidateAll() error {
	return m.validate(true)
}

func (m *Product) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ShopId

	// no validation rules for Name

	// no validation rules for Title

	// no validation rules for Price

	if all {
		switch v := interface{}(m.GetThumb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Thumb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Thumb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetThumb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "Thumb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetImages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Images[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Images[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductValidationError{
					field:  fmt.Sprintf("Images[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOverview() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Overview[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Overview[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductValidationError{
					field:  fmt.Sprintf("Overview[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Specs

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Inventory

	// no validation rules for State

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for PublishAt

	// no validation rules for Version

	if len(errors) > 0 {
		return ProductMultiError(errors)
	}

	return nil
}

// ProductMultiError is an error wrapping multiple validation errors returned
// by Product.ValidateAll() if the designated constraints aren't met.
type ProductMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductMultiError) AllErrors() []error { return m }

// ProductValidationError is the validation error returned by Product.Validate
// if the designated constraints aren't met.
type ProductValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductValidationError) ErrorName() string { return "ProductValidationError" }

// Error satisfies the builtin error interface
func (e ProductValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProduct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductValidationError{}

// Validate checks the field values on CreateProduct with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateProduct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProduct with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateProductMultiError, or
// nil if none found.
func (m *CreateProduct) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProduct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ShopId

	// no validation rules for Name

	// no validation rules for Title

	// no validation rules for Price

	if all {
		switch v := interface{}(m.GetThumb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProductValidationError{
					field:  "Thumb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProductValidationError{
					field:  "Thumb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetThumb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProductValidationError{
				field:  "Thumb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetImages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateProductValidationError{
						field:  fmt.Sprintf("Images[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateProductValidationError{
						field:  fmt.Sprintf("Images[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateProductValidationError{
					field:  fmt.Sprintf("Images[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProductValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProductValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProductValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOverview() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateProductValidationError{
						field:  fmt.Sprintf("Overview[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateProductValidationError{
						field:  fmt.Sprintf("Overview[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateProductValidationError{
					field:  fmt.Sprintf("Overview[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Specs

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateProductValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateProductValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateProductValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Inventory

	// no validation rules for PublishAt

	if len(errors) > 0 {
		return CreateProductMultiError(errors)
	}

	return nil
}

// CreateProductMultiError is an error wrapping multiple validation errors
// returned by CreateProduct.ValidateAll() if the designated constraints
// aren't met.
type CreateProductMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProductMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProductMultiError) AllErrors() []error { return m }

// CreateProductValidationError is the validation error returned by
// CreateProduct.Validate if the designated constraints aren't met.
type CreateProductValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProductValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProductValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProductValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProductValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProductValidationError) ErrorName() string { return "CreateProductValidationError" }

// Error satisfies the builtin error interface
func (e CreateProductValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProduct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProductValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProductValidationError{}

// Validate checks the field values on ProductCard with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductCard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductCard with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductCardMultiError, or
// nil if none found.
func (m *ProductCard) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductCard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ShopId

	// no validation rules for Name

	// no validation rules for Title

	// no validation rules for Price

	if all {
		switch v := interface{}(m.GetThumb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductCardValidationError{
					field:  "Thumb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductCardValidationError{
					field:  "Thumb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetThumb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductCardValidationError{
				field:  "Thumb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductCardValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductCardValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductCardValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductCardValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductCardValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductCardValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PublishAt

	// no validation rules for State

	// no validation rules for Version

	if len(errors) > 0 {
		return ProductCardMultiError(errors)
	}

	return nil
}

// ProductCardMultiError is an error wrapping multiple validation errors
// returned by ProductCard.ValidateAll() if the designated constraints aren't met.
type ProductCardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductCardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductCardMultiError) AllErrors() []error { return m }

// ProductCardValidationError is the validation error returned by
// ProductCard.Validate if the designated constraints aren't met.
type ProductCardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductCardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductCardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductCardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductCardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductCardValidationError) ErrorName() string { return "ProductCardValidationError" }

// Error satisfies the builtin error interface
func (e ProductCardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductCardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductCardValidationError{}

// Validate checks the field values on Sku with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Sku) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sku with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SkuMultiError, or nil if none found.
func (m *Sku) ValidateAll() error {
	return m.validate(true)
}

func (m *Sku) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for Name

	// no validation rules for ProductId

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SkuValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SkuValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SkuValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SkuMultiError(errors)
	}

	return nil
}

// SkuMultiError is an error wrapping multiple validation errors returned by
// Sku.ValidateAll() if the designated constraints aren't met.
type SkuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SkuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SkuMultiError) AllErrors() []error { return m }

// SkuValidationError is the validation error returned by Sku.Validate if the
// designated constraints aren't met.
type SkuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SkuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SkuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SkuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SkuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SkuValidationError) ErrorName() string { return "SkuValidationError" }

// Error satisfies the builtin error interface
func (e SkuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSku.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SkuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SkuValidationError{}

// Validate checks the field values on SkuOnlyId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SkuOnlyId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SkuOnlyId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SkuOnlyIdMultiError, or nil
// if none found.
func (m *SkuOnlyId) ValidateAll() error {
	return m.validate(true)
}

func (m *SkuOnlyId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for Name

	// no validation rules for ProductId

	if len(errors) > 0 {
		return SkuOnlyIdMultiError(errors)
	}

	return nil
}

// SkuOnlyIdMultiError is an error wrapping multiple validation errors returned
// by SkuOnlyId.ValidateAll() if the designated constraints aren't met.
type SkuOnlyIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SkuOnlyIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SkuOnlyIdMultiError) AllErrors() []error { return m }

// SkuOnlyIdValidationError is the validation error returned by
// SkuOnlyId.Validate if the designated constraints aren't met.
type SkuOnlyIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SkuOnlyIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SkuOnlyIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SkuOnlyIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SkuOnlyIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SkuOnlyIdValidationError) ErrorName() string { return "SkuOnlyIdValidationError" }

// Error satisfies the builtin error interface
func (e SkuOnlyIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSkuOnlyId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SkuOnlyIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SkuOnlyIdValidationError{}

// Validate checks the field values on Collection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Collection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionMultiError, or
// nil if none found.
func (m *Collection) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ShopId

	// no validation rules for Name

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetCover()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Cover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Cover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCover()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionValidationError{
				field:  "Cover",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for State

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for PublishAt

	// no validation rules for Version

	for idx, item := range m.GetSkus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionValidationError{
						field:  fmt.Sprintf("Skus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionValidationError{
						field:  fmt.Sprintf("Skus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionValidationError{
					field:  fmt.Sprintf("Skus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CollectionMultiError(errors)
	}

	return nil
}

// CollectionMultiError is an error wrapping multiple validation errors
// returned by Collection.ValidateAll() if the designated constraints aren't met.
type CollectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionMultiError) AllErrors() []error { return m }

// CollectionValidationError is the validation error returned by
// Collection.Validate if the designated constraints aren't met.
type CollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionValidationError) ErrorName() string { return "CollectionValidationError" }

// Error satisfies the builtin error interface
func (e CollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionValidationError{}

// Validate checks the field values on CreateCollection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateCollection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCollection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCollectionMultiError, or nil if none found.
func (m *CreateCollection) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCollection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ShopId

	// no validation rules for Name

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetCover()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCollectionValidationError{
					field:  "Cover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCollectionValidationError{
					field:  "Cover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCover()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCollectionValidationError{
				field:  "Cover",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCollectionValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCollectionValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCollectionValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateCollectionValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateCollectionValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateCollectionValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PublishAt

	for idx, item := range m.GetSkusOnlyId() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateCollectionValidationError{
						field:  fmt.Sprintf("SkusOnlyId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateCollectionValidationError{
						field:  fmt.Sprintf("SkusOnlyId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateCollectionValidationError{
					field:  fmt.Sprintf("SkusOnlyId[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateCollectionMultiError(errors)
	}

	return nil
}

// CreateCollectionMultiError is an error wrapping multiple validation errors
// returned by CreateCollection.ValidateAll() if the designated constraints
// aren't met.
type CreateCollectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCollectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCollectionMultiError) AllErrors() []error { return m }

// CreateCollectionValidationError is the validation error returned by
// CreateCollection.Validate if the designated constraints aren't met.
type CreateCollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCollectionValidationError) ErrorName() string { return "CreateCollectionValidationError" }

// Error satisfies the builtin error interface
func (e CreateCollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCollectionValidationError{}

// Validate checks the field values on CollectionCard with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CollectionCard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCard with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionCardMultiError,
// or nil if none found.
func (m *CollectionCard) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ShopId

	// no validation rules for Name

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetCover()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCardValidationError{
					field:  "Cover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCardValidationError{
					field:  "Cover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCover()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCardValidationError{
				field:  "Cover",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVideo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCardValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCardValidationError{
					field:  "Video",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVideo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCardValidationError{
				field:  "Video",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionCardValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionCardValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionCardValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for State

	// no validation rules for Version

	// no validation rules for ProductId

	if all {
		switch v := interface{}(m.GetProductCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionCardValidationError{
					field:  "ProductCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionCardValidationError{
					field:  "ProductCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionCardValidationError{
				field:  "ProductCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionCardMultiError(errors)
	}

	return nil
}

// CollectionCardMultiError is an error wrapping multiple validation errors
// returned by CollectionCard.ValidateAll() if the designated constraints
// aren't met.
type CollectionCardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCardMultiError) AllErrors() []error { return m }

// CollectionCardValidationError is the validation error returned by
// CollectionCard.Validate if the designated constraints aren't met.
type CollectionCardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCardValidationError) ErrorName() string { return "CollectionCardValidationError" }

// Error satisfies the builtin error interface
func (e CollectionCardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCardValidationError{}

// Validate checks the field values on CartItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CartItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CartItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CartItemMultiError, or nil
// if none found.
func (m *CartItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CartItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for CollectionId

	// no validation rules for Quantity

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ProductId

	if all {
		switch v := interface{}(m.GetProductCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CartItemValidationError{
					field:  "ProductCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CartItemValidationError{
					field:  "ProductCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CartItemValidationError{
				field:  "ProductCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CartItemMultiError(errors)
	}

	return nil
}

// CartItemMultiError is an error wrapping multiple validation errors returned
// by CartItem.ValidateAll() if the designated constraints aren't met.
type CartItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CartItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CartItemMultiError) AllErrors() []error { return m }

// CartItemValidationError is the validation error returned by
// CartItem.Validate if the designated constraints aren't met.
type CartItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CartItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CartItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CartItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CartItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CartItemValidationError) ErrorName() string { return "CartItemValidationError" }

// Error satisfies the builtin error interface
func (e CartItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCartItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CartItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CartItemValidationError{}

// Validate checks the field values on OrderItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderItemMultiError, or nil
// if none found.
func (m *OrderItem) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for ProductId

	// no validation rules for Quantity

	// no validation rules for ShotProductId

	if all {
		switch v := interface{}(m.GetShotProductCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderItemValidationError{
					field:  "ShotProductCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderItemValidationError{
					field:  "ShotProductCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShotProductCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderItemValidationError{
				field:  "ShotProductCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderItemMultiError(errors)
	}

	return nil
}

// OrderItemMultiError is an error wrapping multiple validation errors returned
// by OrderItem.ValidateAll() if the designated constraints aren't met.
type OrderItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderItemMultiError) AllErrors() []error { return m }

// OrderItemValidationError is the validation error returned by
// OrderItem.Validate if the designated constraints aren't met.
type OrderItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderItemValidationError) ErrorName() string { return "OrderItemValidationError" }

// Error satisfies the builtin error interface
func (e OrderItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderItemValidationError{}

// Validate checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Order) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrderMultiError, or nil if none found.
func (m *Order) ValidateAll() error {
	return m.validate(true)
}

func (m *Order) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	for idx, item := range m.GetOrderItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderValidationError{
						field:  fmt.Sprintf("OrderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderValidationError{
						field:  fmt.Sprintf("OrderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderValidationError{
					field:  fmt.Sprintf("OrderItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for State

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for PayAt

	// no validation rules for DeliverAt

	// no validation rules for ReceiveAt

	// no validation rules for CancelAt

	// no validation rules for RefundAt

	// no validation rules for RefundAmount

	// no validation rules for TotalAmount

	// no validation rules for TotalQuantity

	// no validation rules for TotalDiscount

	// no validation rules for TotalPay

	// no validation rules for TotalRefund

	// no validation rules for TotalCoupon

	// no validation rules for TotalPoint

	// no validation rules for TotalFreight

	// no validation rules for TotalTax

	// no validation rules for TotalService

	// no validation rules for TotalProfit

	// no validation rules for TotalCost

	// no validation rules for TotalProfitRate

	// no validation rules for TotalCostRate

	// no validation rules for TotalProfitMargin

	// no validation rules for TotalCostMargin

	// no validation rules for TotalProfitMarginRate

	// no validation rules for TotalCostMarginRate

	if len(errors) > 0 {
		return OrderMultiError(errors)
	}

	return nil
}

// OrderMultiError is an error wrapping multiple validation errors returned by
// Order.ValidateAll() if the designated constraints aren't met.
type OrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderMultiError) AllErrors() []error { return m }

// OrderValidationError is the validation error returned by Order.Validate if
// the designated constraints aren't met.
type OrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderValidationError) ErrorName() string { return "OrderValidationError" }

// Error satisfies the builtin error interface
func (e OrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderValidationError{}

// Validate checks the field values on CreateShopReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateShopReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateShopReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateShopReqMultiError, or
// nil if none found.
func (m *CreateShopReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateShopReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Sign

	if all {
		switch v := interface{}(m.GetLogo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateShopReqValidationError{
					field:  "Logo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateShopReqValidationError{
					field:  "Logo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateShopReqValidationError{
				field:  "Logo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateShopReqMultiError(errors)
	}

	return nil
}

// CreateShopReqMultiError is an error wrapping multiple validation errors
// returned by CreateShopReq.ValidateAll() if the designated constraints
// aren't met.
type CreateShopReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateShopReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateShopReqMultiError) AllErrors() []error { return m }

// CreateShopReqValidationError is the validation error returned by
// CreateShopReq.Validate if the designated constraints aren't met.
type CreateShopReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateShopReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateShopReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateShopReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateShopReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateShopReqValidationError) ErrorName() string { return "CreateShopReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateShopReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateShopReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateShopReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateShopReqValidationError{}

// Validate checks the field values on CreateShopResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateShopResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateShopResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateShopResponseMultiError, or nil if none found.
func (m *CreateShopResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateShopResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CreateShopResponseMultiError(errors)
	}

	return nil
}

// CreateShopResponseMultiError is an error wrapping multiple validation errors
// returned by CreateShopResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateShopResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateShopResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateShopResponseMultiError) AllErrors() []error { return m }

// CreateShopResponseValidationError is the validation error returned by
// CreateShopResponse.Validate if the designated constraints aren't met.
type CreateShopResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateShopResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateShopResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateShopResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateShopResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateShopResponseValidationError) ErrorName() string {
	return "CreateShopResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateShopResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateShopResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateShopResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateShopResponseValidationError{}

// Validate checks the field values on GetShopByIdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetShopByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetShopByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetShopByIdReqMultiError,
// or nil if none found.
func (m *GetShopByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetShopByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetShopByIdReqMultiError(errors)
	}

	return nil
}

// GetShopByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetShopByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetShopByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetShopByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetShopByIdReqMultiError) AllErrors() []error { return m }

// GetShopByIdReqValidationError is the validation error returned by
// GetShopByIdReq.Validate if the designated constraints aren't met.
type GetShopByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetShopByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetShopByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetShopByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetShopByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetShopByIdReqValidationError) ErrorName() string { return "GetShopByIdReqValidationError" }

// Error satisfies the builtin error interface
func (e GetShopByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetShopByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetShopByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetShopByIdReqValidationError{}

// Validate checks the field values on GetShopByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetShopByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetShopByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetShopByIdResponseMultiError, or nil if none found.
func (m *GetShopByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetShopByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetShop()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetShopByIdResponseValidationError{
					field:  "Shop",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetShopByIdResponseValidationError{
					field:  "Shop",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShop()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetShopByIdResponseValidationError{
				field:  "Shop",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetShopByIdResponseMultiError(errors)
	}

	return nil
}

// GetShopByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetShopByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetShopByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetShopByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetShopByIdResponseMultiError) AllErrors() []error { return m }

// GetShopByIdResponseValidationError is the validation error returned by
// GetShopByIdResponse.Validate if the designated constraints aren't met.
type GetShopByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetShopByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetShopByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetShopByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetShopByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetShopByIdResponseValidationError) ErrorName() string {
	return "GetShopByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetShopByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetShopByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetShopByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetShopByIdResponseValidationError{}

// Validate checks the field values on CreateProductReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateProductReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProductReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProductReqMultiError, or nil if none found.
func (m *CreateProductReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProductReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProductReqValidationError{
					field:  "CreateProduct",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProductReqValidationError{
					field:  "CreateProduct",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProductReqValidationError{
				field:  "CreateProduct",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateProductReqMultiError(errors)
	}

	return nil
}

// CreateProductReqMultiError is an error wrapping multiple validation errors
// returned by CreateProductReq.ValidateAll() if the designated constraints
// aren't met.
type CreateProductReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProductReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProductReqMultiError) AllErrors() []error { return m }

// CreateProductReqValidationError is the validation error returned by
// CreateProductReq.Validate if the designated constraints aren't met.
type CreateProductReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProductReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProductReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProductReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProductReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProductReqValidationError) ErrorName() string { return "CreateProductReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateProductReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProductReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProductReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProductReqValidationError{}

// Validate checks the field values on CreateProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProductResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProductResponseMultiError, or nil if none found.
func (m *CreateProductResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProductResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CreateProductResponseMultiError(errors)
	}

	return nil
}

// CreateProductResponseMultiError is an error wrapping multiple validation
// errors returned by CreateProductResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateProductResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProductResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProductResponseMultiError) AllErrors() []error { return m }

// CreateProductResponseValidationError is the validation error returned by
// CreateProductResponse.Validate if the designated constraints aren't met.
type CreateProductResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProductResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProductResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProductResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProductResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProductResponseValidationError) ErrorName() string {
	return "CreateProductResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProductResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProductResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProductResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProductResponseValidationError{}

// Validate checks the field values on GetProductByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetProductByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProductByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProductByIdReqMultiError, or nil if none found.
func (m *GetProductByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProductByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetProductByIdReqMultiError(errors)
	}

	return nil
}

// GetProductByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetProductByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetProductByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProductByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProductByIdReqMultiError) AllErrors() []error { return m }

// GetProductByIdReqValidationError is the validation error returned by
// GetProductByIdReq.Validate if the designated constraints aren't met.
type GetProductByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProductByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProductByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProductByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProductByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProductByIdReqValidationError) ErrorName() string {
	return "GetProductByIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetProductByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProductByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProductByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProductByIdReqValidationError{}

// Validate checks the field values on GetProductByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProductByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProductByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProductByIdResponseMultiError, or nil if none found.
func (m *GetProductByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProductByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProductByIdResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProductByIdResponseValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProductByIdResponseValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProductByIdResponseMultiError(errors)
	}

	return nil
}

// GetProductByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetProductByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetProductByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProductByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProductByIdResponseMultiError) AllErrors() []error { return m }

// GetProductByIdResponseValidationError is the validation error returned by
// GetProductByIdResponse.Validate if the designated constraints aren't met.
type GetProductByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProductByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProductByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProductByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProductByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProductByIdResponseValidationError) ErrorName() string {
	return "GetProductByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetProductByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProductByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProductByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProductByIdResponseValidationError{}

// Validate checks the field values on MapProductByIdsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapProductByIdsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapProductByIdsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapProductByIdsReqMultiError, or nil if none found.
func (m *MapProductByIdsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapProductByIdsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MapProductByIdsReqMultiError(errors)
	}

	return nil
}

// MapProductByIdsReqMultiError is an error wrapping multiple validation errors
// returned by MapProductByIdsReq.ValidateAll() if the designated constraints
// aren't met.
type MapProductByIdsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapProductByIdsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapProductByIdsReqMultiError) AllErrors() []error { return m }

// MapProductByIdsReqValidationError is the validation error returned by
// MapProductByIdsReq.Validate if the designated constraints aren't met.
type MapProductByIdsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapProductByIdsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapProductByIdsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapProductByIdsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapProductByIdsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapProductByIdsReqValidationError) ErrorName() string {
	return "MapProductByIdsReqValidationError"
}

// Error satisfies the builtin error interface
func (e MapProductByIdsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapProductByIdsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapProductByIdsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapProductByIdsReqValidationError{}

// Validate checks the field values on MapProductByIdsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapProductByIdsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapProductByIdsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapProductByIdsResponseMultiError, or nil if none found.
func (m *MapProductByIdsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapProductByIdsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetProducts()))
		i := 0
		for key := range m.GetProducts() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetProducts()[key]
			_ = val

			// no validation rules for Products[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapProductByIdsResponseValidationError{
							field:  fmt.Sprintf("Products[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapProductByIdsResponseValidationError{
							field:  fmt.Sprintf("Products[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapProductByIdsResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return MapProductByIdsResponseMultiError(errors)
	}

	return nil
}

// MapProductByIdsResponseMultiError is an error wrapping multiple validation
// errors returned by MapProductByIdsResponse.ValidateAll() if the designated
// constraints aren't met.
type MapProductByIdsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapProductByIdsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapProductByIdsResponseMultiError) AllErrors() []error { return m }

// MapProductByIdsResponseValidationError is the validation error returned by
// MapProductByIdsResponse.Validate if the designated constraints aren't met.
type MapProductByIdsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapProductByIdsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapProductByIdsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapProductByIdsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapProductByIdsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapProductByIdsResponseValidationError) ErrorName() string {
	return "MapProductByIdsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapProductByIdsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapProductByIdsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapProductByIdsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapProductByIdsResponseValidationError{}

// Validate checks the field values on GetCollectionByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCollectionByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCollectionByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCollectionByIdReqMultiError, or nil if none found.
func (m *GetCollectionByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCollectionByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetCollectionByIdReqMultiError(errors)
	}

	return nil
}

// GetCollectionByIdReqMultiError is an error wrapping multiple validation
// errors returned by GetCollectionByIdReq.ValidateAll() if the designated
// constraints aren't met.
type GetCollectionByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCollectionByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCollectionByIdReqMultiError) AllErrors() []error { return m }

// GetCollectionByIdReqValidationError is the validation error returned by
// GetCollectionByIdReq.Validate if the designated constraints aren't met.
type GetCollectionByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCollectionByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCollectionByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCollectionByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCollectionByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCollectionByIdReqValidationError) ErrorName() string {
	return "GetCollectionByIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetCollectionByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCollectionByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCollectionByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCollectionByIdReqValidationError{}

// Validate checks the field values on GetCollectionByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCollectionByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCollectionByIdResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCollectionByIdResponseMultiError, or nil if none found.
func (m *GetCollectionByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCollectionByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCollectionByIdResponseValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCollectionByIdResponseValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCollectionByIdResponseValidationError{
				field:  "Collection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCollectionByIdResponseMultiError(errors)
	}

	return nil
}

// GetCollectionByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetCollectionByIdResponse.ValidateAll() if the
// designated constraints aren't met.
type GetCollectionByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCollectionByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCollectionByIdResponseMultiError) AllErrors() []error { return m }

// GetCollectionByIdResponseValidationError is the validation error returned by
// GetCollectionByIdResponse.Validate if the designated constraints aren't met.
type GetCollectionByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCollectionByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCollectionByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCollectionByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCollectionByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCollectionByIdResponseValidationError) ErrorName() string {
	return "GetCollectionByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCollectionByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCollectionByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCollectionByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCollectionByIdResponseValidationError{}

// Validate checks the field values on GetCollectionCardByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCollectionCardByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCollectionCardByIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCollectionCardByIdReqMultiError, or nil if none found.
func (m *GetCollectionCardByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCollectionCardByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetCollectionCardByIdReqMultiError(errors)
	}

	return nil
}

// GetCollectionCardByIdReqMultiError is an error wrapping multiple validation
// errors returned by GetCollectionCardByIdReq.ValidateAll() if the designated
// constraints aren't met.
type GetCollectionCardByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCollectionCardByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCollectionCardByIdReqMultiError) AllErrors() []error { return m }

// GetCollectionCardByIdReqValidationError is the validation error returned by
// GetCollectionCardByIdReq.Validate if the designated constraints aren't met.
type GetCollectionCardByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCollectionCardByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCollectionCardByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCollectionCardByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCollectionCardByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCollectionCardByIdReqValidationError) ErrorName() string {
	return "GetCollectionCardByIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetCollectionCardByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCollectionCardByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCollectionCardByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCollectionCardByIdReqValidationError{}

// Validate checks the field values on GetCollectionCardByIdResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCollectionCardByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCollectionCardByIdResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetCollectionCardByIdResponseMultiError, or nil if none found.
func (m *GetCollectionCardByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCollectionCardByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCollectionCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCollectionCardByIdResponseValidationError{
					field:  "CollectionCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCollectionCardByIdResponseValidationError{
					field:  "CollectionCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollectionCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCollectionCardByIdResponseValidationError{
				field:  "CollectionCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCollectionCardByIdResponseMultiError(errors)
	}

	return nil
}

// GetCollectionCardByIdResponseMultiError is an error wrapping multiple
// validation errors returned by GetCollectionCardByIdResponse.ValidateAll()
// if the designated constraints aren't met.
type GetCollectionCardByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCollectionCardByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCollectionCardByIdResponseMultiError) AllErrors() []error { return m }

// GetCollectionCardByIdResponseValidationError is the validation error
// returned by GetCollectionCardByIdResponse.Validate if the designated
// constraints aren't met.
type GetCollectionCardByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCollectionCardByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCollectionCardByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCollectionCardByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCollectionCardByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCollectionCardByIdResponseValidationError) ErrorName() string {
	return "GetCollectionCardByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCollectionCardByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCollectionCardByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCollectionCardByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCollectionCardByIdResponseValidationError{}

// Validate checks the field values on CreateCollectionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCollectionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCollectionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCollectionReqMultiError, or nil if none found.
func (m *CreateCollectionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCollectionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCollectionReqValidationError{
					field:  "CreateCollection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCollectionReqValidationError{
					field:  "CreateCollection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCollectionReqValidationError{
				field:  "CreateCollection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCollectionReqMultiError(errors)
	}

	return nil
}

// CreateCollectionReqMultiError is an error wrapping multiple validation
// errors returned by CreateCollectionReq.ValidateAll() if the designated
// constraints aren't met.
type CreateCollectionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCollectionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCollectionReqMultiError) AllErrors() []error { return m }

// CreateCollectionReqValidationError is the validation error returned by
// CreateCollectionReq.Validate if the designated constraints aren't met.
type CreateCollectionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCollectionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCollectionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCollectionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCollectionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCollectionReqValidationError) ErrorName() string {
	return "CreateCollectionReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCollectionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCollectionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCollectionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCollectionReqValidationError{}

// Validate checks the field values on CreateCollectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCollectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCollectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCollectionResponseMultiError, or nil if none found.
func (m *CreateCollectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCollectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CreateCollectionResponseMultiError(errors)
	}

	return nil
}

// CreateCollectionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCollectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCollectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCollectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCollectionResponseMultiError) AllErrors() []error { return m }

// CreateCollectionResponseValidationError is the validation error returned by
// CreateCollectionResponse.Validate if the designated constraints aren't met.
type CreateCollectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCollectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCollectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCollectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCollectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCollectionResponseValidationError) ErrorName() string {
	return "CreateCollectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCollectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCollectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCollectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCollectionResponseValidationError{}

// Validate checks the field values on MapCollectionCardByIdsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapCollectionCardByIdsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapCollectionCardByIdsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapCollectionCardByIdsReqMultiError, or nil if none found.
func (m *MapCollectionCardByIdsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapCollectionCardByIdsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MapCollectionCardByIdsReqMultiError(errors)
	}

	return nil
}

// MapCollectionCardByIdsReqMultiError is an error wrapping multiple validation
// errors returned by MapCollectionCardByIdsReq.ValidateAll() if the
// designated constraints aren't met.
type MapCollectionCardByIdsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapCollectionCardByIdsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapCollectionCardByIdsReqMultiError) AllErrors() []error { return m }

// MapCollectionCardByIdsReqValidationError is the validation error returned by
// MapCollectionCardByIdsReq.Validate if the designated constraints aren't met.
type MapCollectionCardByIdsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapCollectionCardByIdsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapCollectionCardByIdsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapCollectionCardByIdsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapCollectionCardByIdsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapCollectionCardByIdsReqValidationError) ErrorName() string {
	return "MapCollectionCardByIdsReqValidationError"
}

// Error satisfies the builtin error interface
func (e MapCollectionCardByIdsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapCollectionCardByIdsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapCollectionCardByIdsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapCollectionCardByIdsReqValidationError{}

// Validate checks the field values on MapCollectionCardByIdsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapCollectionCardByIdsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapCollectionCardByIdsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MapCollectionCardByIdsResponseMultiError, or nil if none found.
func (m *MapCollectionCardByIdsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapCollectionCardByIdsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetCollectionCards()))
		i := 0
		for key := range m.GetCollectionCards() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCollectionCards()[key]
			_ = val

			// no validation rules for CollectionCards[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapCollectionCardByIdsResponseValidationError{
							field:  fmt.Sprintf("CollectionCards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapCollectionCardByIdsResponseValidationError{
							field:  fmt.Sprintf("CollectionCards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapCollectionCardByIdsResponseValidationError{
						field:  fmt.Sprintf("CollectionCards[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return MapCollectionCardByIdsResponseMultiError(errors)
	}

	return nil
}

// MapCollectionCardByIdsResponseMultiError is an error wrapping multiple
// validation errors returned by MapCollectionCardByIdsResponse.ValidateAll()
// if the designated constraints aren't met.
type MapCollectionCardByIdsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapCollectionCardByIdsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapCollectionCardByIdsResponseMultiError) AllErrors() []error { return m }

// MapCollectionCardByIdsResponseValidationError is the validation error
// returned by MapCollectionCardByIdsResponse.Validate if the designated
// constraints aren't met.
type MapCollectionCardByIdsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapCollectionCardByIdsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapCollectionCardByIdsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapCollectionCardByIdsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapCollectionCardByIdsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapCollectionCardByIdsResponseValidationError) ErrorName() string {
	return "MapCollectionCardByIdsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapCollectionCardByIdsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapCollectionCardByIdsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapCollectionCardByIdsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapCollectionCardByIdsResponseValidationError{}

// Validate checks the field values on MapCollectionCardByShopIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapCollectionCardByShopIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapCollectionCardByShopIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapCollectionCardByShopIdReqMultiError, or nil if none found.
func (m *MapCollectionCardByShopIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapCollectionCardByShopIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapCollectionCardByShopIdReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapCollectionCardByShopIdReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapCollectionCardByShopIdReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapCollectionCardByShopIdReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapCollectionCardByShopIdReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapCollectionCardByShopIdReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MapCollectionCardByShopIdReqMultiError(errors)
	}

	return nil
}

// MapCollectionCardByShopIdReqMultiError is an error wrapping multiple
// validation errors returned by MapCollectionCardByShopIdReq.ValidateAll() if
// the designated constraints aren't met.
type MapCollectionCardByShopIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapCollectionCardByShopIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapCollectionCardByShopIdReqMultiError) AllErrors() []error { return m }

// MapCollectionCardByShopIdReqValidationError is the validation error returned
// by MapCollectionCardByShopIdReq.Validate if the designated constraints
// aren't met.
type MapCollectionCardByShopIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapCollectionCardByShopIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapCollectionCardByShopIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapCollectionCardByShopIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapCollectionCardByShopIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapCollectionCardByShopIdReqValidationError) ErrorName() string {
	return "MapCollectionCardByShopIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e MapCollectionCardByShopIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapCollectionCardByShopIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapCollectionCardByShopIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapCollectionCardByShopIdReqValidationError{}

// Validate checks the field values on MapCollectionCardByShopIdResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MapCollectionCardByShopIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapCollectionCardByShopIdResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MapCollectionCardByShopIdResponseMultiError, or nil if none found.
func (m *MapCollectionCardByShopIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapCollectionCardByShopIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetCollectionCards()))
		i := 0
		for key := range m.GetCollectionCards() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCollectionCards()[key]
			_ = val

			// no validation rules for CollectionCards[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapCollectionCardByShopIdResponseValidationError{
							field:  fmt.Sprintf("CollectionCards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapCollectionCardByShopIdResponseValidationError{
							field:  fmt.Sprintf("CollectionCards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapCollectionCardByShopIdResponseValidationError{
						field:  fmt.Sprintf("CollectionCards[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapCollectionCardByShopIdResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapCollectionCardByShopIdResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapCollectionCardByShopIdResponseValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MapCollectionCardByShopIdResponseMultiError(errors)
	}

	return nil
}

// MapCollectionCardByShopIdResponseMultiError is an error wrapping multiple
// validation errors returned by
// MapCollectionCardByShopIdResponse.ValidateAll() if the designated
// constraints aren't met.
type MapCollectionCardByShopIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapCollectionCardByShopIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapCollectionCardByShopIdResponseMultiError) AllErrors() []error { return m }

// MapCollectionCardByShopIdResponseValidationError is the validation error
// returned by MapCollectionCardByShopIdResponse.Validate if the designated
// constraints aren't met.
type MapCollectionCardByShopIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapCollectionCardByShopIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapCollectionCardByShopIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapCollectionCardByShopIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapCollectionCardByShopIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapCollectionCardByShopIdResponseValidationError) ErrorName() string {
	return "MapCollectionCardByShopIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapCollectionCardByShopIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapCollectionCardByShopIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapCollectionCardByShopIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapCollectionCardByShopIdResponseValidationError{}

// Validate checks the field values on UpdateCollectionStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCollectionStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCollectionStateReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCollectionStateReqMultiError, or nil if none found.
func (m *UpdateCollectionStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCollectionStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for State

	if len(errors) > 0 {
		return UpdateCollectionStateReqMultiError(errors)
	}

	return nil
}

// UpdateCollectionStateReqMultiError is an error wrapping multiple validation
// errors returned by UpdateCollectionStateReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateCollectionStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCollectionStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCollectionStateReqMultiError) AllErrors() []error { return m }

// UpdateCollectionStateReqValidationError is the validation error returned by
// UpdateCollectionStateReq.Validate if the designated constraints aren't met.
type UpdateCollectionStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCollectionStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCollectionStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCollectionStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCollectionStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCollectionStateReqValidationError) ErrorName() string {
	return "UpdateCollectionStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCollectionStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCollectionStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCollectionStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCollectionStateReqValidationError{}

// Validate checks the field values on UpdateCollectionStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCollectionStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCollectionStateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateCollectionStateResponseMultiError, or nil if none found.
func (m *UpdateCollectionStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCollectionStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateCollectionStateResponseMultiError(errors)
	}

	return nil
}

// UpdateCollectionStateResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateCollectionStateResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateCollectionStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCollectionStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCollectionStateResponseMultiError) AllErrors() []error { return m }

// UpdateCollectionStateResponseValidationError is the validation error
// returned by UpdateCollectionStateResponse.Validate if the designated
// constraints aren't met.
type UpdateCollectionStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCollectionStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCollectionStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCollectionStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCollectionStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCollectionStateResponseValidationError) ErrorName() string {
	return "UpdateCollectionStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCollectionStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCollectionStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCollectionStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCollectionStateResponseValidationError{}

// Validate checks the field values on UpdateCollectionSkuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCollectionSkuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCollectionSkuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCollectionSkuReqMultiError, or nil if none found.
func (m *UpdateCollectionSkuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCollectionSkuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetSkusOnlyId() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateCollectionSkuReqValidationError{
						field:  fmt.Sprintf("SkusOnlyId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateCollectionSkuReqValidationError{
						field:  fmt.Sprintf("SkusOnlyId[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateCollectionSkuReqValidationError{
					field:  fmt.Sprintf("SkusOnlyId[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateCollectionSkuReqMultiError(errors)
	}

	return nil
}

// UpdateCollectionSkuReqMultiError is an error wrapping multiple validation
// errors returned by UpdateCollectionSkuReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateCollectionSkuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCollectionSkuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCollectionSkuReqMultiError) AllErrors() []error { return m }

// UpdateCollectionSkuReqValidationError is the validation error returned by
// UpdateCollectionSkuReq.Validate if the designated constraints aren't met.
type UpdateCollectionSkuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCollectionSkuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCollectionSkuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCollectionSkuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCollectionSkuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCollectionSkuReqValidationError) ErrorName() string {
	return "UpdateCollectionSkuReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCollectionSkuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCollectionSkuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCollectionSkuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCollectionSkuReqValidationError{}

// Validate checks the field values on UpdateCollectionSkuResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCollectionSkuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCollectionSkuResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCollectionSkuResponseMultiError, or nil if none found.
func (m *UpdateCollectionSkuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCollectionSkuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateCollectionSkuResponseMultiError(errors)
	}

	return nil
}

// UpdateCollectionSkuResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateCollectionSkuResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateCollectionSkuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCollectionSkuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCollectionSkuResponseMultiError) AllErrors() []error { return m }

// UpdateCollectionSkuResponseValidationError is the validation error returned
// by UpdateCollectionSkuResponse.Validate if the designated constraints
// aren't met.
type UpdateCollectionSkuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCollectionSkuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCollectionSkuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCollectionSkuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCollectionSkuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCollectionSkuResponseValidationError) ErrorName() string {
	return "UpdateCollectionSkuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCollectionSkuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCollectionSkuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCollectionSkuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCollectionSkuResponseValidationError{}

// Validate checks the field values on CreateCartItemReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateCartItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCartItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCartItemReqMultiError, or nil if none found.
func (m *CreateCartItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCartItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for CollectionId

	// no validation rules for ProductId

	// no validation rules for Quantity

	if len(errors) > 0 {
		return CreateCartItemReqMultiError(errors)
	}

	return nil
}

// CreateCartItemReqMultiError is an error wrapping multiple validation errors
// returned by CreateCartItemReq.ValidateAll() if the designated constraints
// aren't met.
type CreateCartItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCartItemReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCartItemReqMultiError) AllErrors() []error { return m }

// CreateCartItemReqValidationError is the validation error returned by
// CreateCartItemReq.Validate if the designated constraints aren't met.
type CreateCartItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCartItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCartItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCartItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCartItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCartItemReqValidationError) ErrorName() string {
	return "CreateCartItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCartItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCartItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCartItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCartItemReqValidationError{}

// Validate checks the field values on CreateCartItemResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCartItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCartItemResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCartItemResponseMultiError, or nil if none found.
func (m *CreateCartItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCartItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CreateCartItemResponseMultiError(errors)
	}

	return nil
}

// CreateCartItemResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCartItemResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCartItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCartItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCartItemResponseMultiError) AllErrors() []error { return m }

// CreateCartItemResponseValidationError is the validation error returned by
// CreateCartItemResponse.Validate if the designated constraints aren't met.
type CreateCartItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCartItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCartItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCartItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCartItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCartItemResponseValidationError) ErrorName() string {
	return "CreateCartItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCartItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCartItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCartItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCartItemResponseValidationError{}

// Validate checks the field values on MapCartItemByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapCartItemByUidReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapCartItemByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapCartItemByUidReqMultiError, or nil if none found.
func (m *MapCartItemByUidReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapCartItemByUidReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return MapCartItemByUidReqMultiError(errors)
	}

	return nil
}

// MapCartItemByUidReqMultiError is an error wrapping multiple validation
// errors returned by MapCartItemByUidReq.ValidateAll() if the designated
// constraints aren't met.
type MapCartItemByUidReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapCartItemByUidReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapCartItemByUidReqMultiError) AllErrors() []error { return m }

// MapCartItemByUidReqValidationError is the validation error returned by
// MapCartItemByUidReq.Validate if the designated constraints aren't met.
type MapCartItemByUidReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapCartItemByUidReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapCartItemByUidReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapCartItemByUidReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapCartItemByUidReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapCartItemByUidReqValidationError) ErrorName() string {
	return "MapCartItemByUidReqValidationError"
}

// Error satisfies the builtin error interface
func (e MapCartItemByUidReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapCartItemByUidReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapCartItemByUidReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapCartItemByUidReqValidationError{}

// Validate checks the field values on MapCartItemByUidResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapCartItemByUidResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapCartItemByUidResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapCartItemByUidResponseMultiError, or nil if none found.
func (m *MapCartItemByUidResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapCartItemByUidResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetCartItems()))
		i := 0
		for key := range m.GetCartItems() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCartItems()[key]
			_ = val

			// no validation rules for CartItems[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapCartItemByUidResponseValidationError{
							field:  fmt.Sprintf("CartItems[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapCartItemByUidResponseValidationError{
							field:  fmt.Sprintf("CartItems[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapCartItemByUidResponseValidationError{
						field:  fmt.Sprintf("CartItems[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return MapCartItemByUidResponseMultiError(errors)
	}

	return nil
}

// MapCartItemByUidResponseMultiError is an error wrapping multiple validation
// errors returned by MapCartItemByUidResponse.ValidateAll() if the designated
// constraints aren't met.
type MapCartItemByUidResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapCartItemByUidResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapCartItemByUidResponseMultiError) AllErrors() []error { return m }

// MapCartItemByUidResponseValidationError is the validation error returned by
// MapCartItemByUidResponse.Validate if the designated constraints aren't met.
type MapCartItemByUidResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapCartItemByUidResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapCartItemByUidResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapCartItemByUidResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapCartItemByUidResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapCartItemByUidResponseValidationError) ErrorName() string {
	return "MapCartItemByUidResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapCartItemByUidResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapCartItemByUidResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapCartItemByUidResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapCartItemByUidResponseValidationError{}

// Validate checks the field values on UpdateCartItemQuantityReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCartItemQuantityReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCartItemQuantityReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCartItemQuantityReqMultiError, or nil if none found.
func (m *UpdateCartItemQuantityReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCartItemQuantityReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Quantity

	if len(errors) > 0 {
		return UpdateCartItemQuantityReqMultiError(errors)
	}

	return nil
}

// UpdateCartItemQuantityReqMultiError is an error wrapping multiple validation
// errors returned by UpdateCartItemQuantityReq.ValidateAll() if the
// designated constraints aren't met.
type UpdateCartItemQuantityReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCartItemQuantityReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCartItemQuantityReqMultiError) AllErrors() []error { return m }

// UpdateCartItemQuantityReqValidationError is the validation error returned by
// UpdateCartItemQuantityReq.Validate if the designated constraints aren't met.
type UpdateCartItemQuantityReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCartItemQuantityReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCartItemQuantityReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCartItemQuantityReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCartItemQuantityReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCartItemQuantityReqValidationError) ErrorName() string {
	return "UpdateCartItemQuantityReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCartItemQuantityReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCartItemQuantityReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCartItemQuantityReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCartItemQuantityReqValidationError{}

// Validate checks the field values on UpdateCartItemQuantityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCartItemQuantityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCartItemQuantityResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateCartItemQuantityResponseMultiError, or nil if none found.
func (m *UpdateCartItemQuantityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCartItemQuantityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return UpdateCartItemQuantityResponseMultiError(errors)
	}

	return nil
}

// UpdateCartItemQuantityResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateCartItemQuantityResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateCartItemQuantityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCartItemQuantityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCartItemQuantityResponseMultiError) AllErrors() []error { return m }

// UpdateCartItemQuantityResponseValidationError is the validation error
// returned by UpdateCartItemQuantityResponse.Validate if the designated
// constraints aren't met.
type UpdateCartItemQuantityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCartItemQuantityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCartItemQuantityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCartItemQuantityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCartItemQuantityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCartItemQuantityResponseValidationError) ErrorName() string {
	return "UpdateCartItemQuantityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCartItemQuantityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCartItemQuantityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCartItemQuantityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCartItemQuantityResponseValidationError{}

// Validate checks the field values on DeleteCartItemReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteCartItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCartItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCartItemReqMultiError, or nil if none found.
func (m *DeleteCartItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCartItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	if len(errors) > 0 {
		return DeleteCartItemReqMultiError(errors)
	}

	return nil
}

// DeleteCartItemReqMultiError is an error wrapping multiple validation errors
// returned by DeleteCartItemReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteCartItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCartItemReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCartItemReqMultiError) AllErrors() []error { return m }

// DeleteCartItemReqValidationError is the validation error returned by
// DeleteCartItemReq.Validate if the designated constraints aren't met.
type DeleteCartItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCartItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCartItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCartItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCartItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCartItemReqValidationError) ErrorName() string {
	return "DeleteCartItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCartItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCartItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCartItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCartItemReqValidationError{}

// Validate checks the field values on DeleteCartItemResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCartItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCartItemResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCartItemResponseMultiError, or nil if none found.
func (m *DeleteCartItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCartItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteCartItemResponseMultiError(errors)
	}

	return nil
}

// DeleteCartItemResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCartItemResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCartItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCartItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCartItemResponseMultiError) AllErrors() []error { return m }

// DeleteCartItemResponseValidationError is the validation error returned by
// DeleteCartItemResponse.Validate if the designated constraints aren't met.
type DeleteCartItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCartItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCartItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCartItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCartItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCartItemResponseValidationError) ErrorName() string {
	return "DeleteCartItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCartItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCartItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCartItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCartItemResponseValidationError{}

// Validate checks the field values on CreateOrderReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateOrderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrderReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateOrderReqMultiError,
// or nil if none found.
func (m *CreateOrderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	for idx, item := range m.GetOrderItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateOrderReqValidationError{
						field:  fmt.Sprintf("OrderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateOrderReqValidationError{
						field:  fmt.Sprintf("OrderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateOrderReqValidationError{
					field:  fmt.Sprintf("OrderItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateOrderReqMultiError(errors)
	}

	return nil
}

// CreateOrderReqMultiError is an error wrapping multiple validation errors
// returned by CreateOrderReq.ValidateAll() if the designated constraints
// aren't met.
type CreateOrderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrderReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrderReqMultiError) AllErrors() []error { return m }

// CreateOrderReqValidationError is the validation error returned by
// CreateOrderReq.Validate if the designated constraints aren't met.
type CreateOrderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrderReqValidationError) ErrorName() string { return "CreateOrderReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateOrderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrderReqValidationError{}

// Validate checks the field values on CreateOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrderResponseMultiError, or nil if none found.
func (m *CreateOrderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrderResponseValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrderResponseValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrderResponseValidationError{
				field:  "Order",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CreateOrderResponseMultiError(errors)
	}

	return nil
}

// CreateOrderResponseMultiError is an error wrapping multiple validation
// errors returned by CreateOrderResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateOrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrderResponseMultiError) AllErrors() []error { return m }

// CreateOrderResponseValidationError is the validation error returned by
// CreateOrderResponse.Validate if the designated constraints aren't met.
type CreateOrderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrderResponseValidationError) ErrorName() string {
	return "CreateOrderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrderResponseValidationError{}

// Validate checks the field values on GetOrderByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetOrderByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderByIdReqMultiError, or nil if none found.
func (m *GetOrderByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetOrderByIdReqMultiError(errors)
	}

	return nil
}

// GetOrderByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetOrderByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetOrderByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderByIdReqMultiError) AllErrors() []error { return m }

// GetOrderByIdReqValidationError is the validation error returned by
// GetOrderByIdReq.Validate if the designated constraints aren't met.
type GetOrderByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderByIdReqValidationError) ErrorName() string { return "GetOrderByIdReqValidationError" }

// Error satisfies the builtin error interface
func (e GetOrderByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderByIdReqValidationError{}

// Validate checks the field values on GetOrderByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderByIdResponseMultiError, or nil if none found.
func (m *GetOrderByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderByIdResponseValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderByIdResponseValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderByIdResponseValidationError{
				field:  "Order",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOrderByIdResponseMultiError(errors)
	}

	return nil
}

// GetOrderByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetOrderByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOrderByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderByIdResponseMultiError) AllErrors() []error { return m }

// GetOrderByIdResponseValidationError is the validation error returned by
// GetOrderByIdResponse.Validate if the designated constraints aren't met.
type GetOrderByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderByIdResponseValidationError) ErrorName() string {
	return "GetOrderByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderByIdResponseValidationError{}

// Validate checks the field values on MapOrderByIdsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MapOrderByIdsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapOrderByIdsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapOrderByIdsReqMultiError, or nil if none found.
func (m *MapOrderByIdsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapOrderByIdsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MapOrderByIdsReqMultiError(errors)
	}

	return nil
}

// MapOrderByIdsReqMultiError is an error wrapping multiple validation errors
// returned by MapOrderByIdsReq.ValidateAll() if the designated constraints
// aren't met.
type MapOrderByIdsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapOrderByIdsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapOrderByIdsReqMultiError) AllErrors() []error { return m }

// MapOrderByIdsReqValidationError is the validation error returned by
// MapOrderByIdsReq.Validate if the designated constraints aren't met.
type MapOrderByIdsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapOrderByIdsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapOrderByIdsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapOrderByIdsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapOrderByIdsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapOrderByIdsReqValidationError) ErrorName() string { return "MapOrderByIdsReqValidationError" }

// Error satisfies the builtin error interface
func (e MapOrderByIdsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapOrderByIdsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapOrderByIdsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapOrderByIdsReqValidationError{}

// Validate checks the field values on MapOrderByIdsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapOrderByIdsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapOrderByIdsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapOrderByIdsResponseMultiError, or nil if none found.
func (m *MapOrderByIdsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapOrderByIdsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetOrders()))
		i := 0
		for key := range m.GetOrders() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOrders()[key]
			_ = val

			// no validation rules for Orders[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapOrderByIdsResponseValidationError{
							field:  fmt.Sprintf("Orders[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapOrderByIdsResponseValidationError{
							field:  fmt.Sprintf("Orders[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapOrderByIdsResponseValidationError{
						field:  fmt.Sprintf("Orders[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return MapOrderByIdsResponseMultiError(errors)
	}

	return nil
}

// MapOrderByIdsResponseMultiError is an error wrapping multiple validation
// errors returned by MapOrderByIdsResponse.ValidateAll() if the designated
// constraints aren't met.
type MapOrderByIdsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapOrderByIdsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapOrderByIdsResponseMultiError) AllErrors() []error { return m }

// MapOrderByIdsResponseValidationError is the validation error returned by
// MapOrderByIdsResponse.Validate if the designated constraints aren't met.
type MapOrderByIdsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapOrderByIdsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapOrderByIdsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapOrderByIdsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapOrderByIdsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapOrderByIdsResponseValidationError) ErrorName() string {
	return "MapOrderByIdsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapOrderByIdsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapOrderByIdsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapOrderByIdsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapOrderByIdsResponseValidationError{}

// Validate checks the field values on MapOrderByUidReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MapOrderByUidReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapOrderByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapOrderByUidReqMultiError, or nil if none found.
func (m *MapOrderByUidReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapOrderByUidReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for State

	// no validation rules for StartTime

	// no validation rules for EndTime

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapOrderByUidReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapOrderByUidReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapOrderByUidReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapOrderByUidReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapOrderByUidReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapOrderByUidReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MapOrderByUidReqMultiError(errors)
	}

	return nil
}

// MapOrderByUidReqMultiError is an error wrapping multiple validation errors
// returned by MapOrderByUidReq.ValidateAll() if the designated constraints
// aren't met.
type MapOrderByUidReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapOrderByUidReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapOrderByUidReqMultiError) AllErrors() []error { return m }

// MapOrderByUidReqValidationError is the validation error returned by
// MapOrderByUidReq.Validate if the designated constraints aren't met.
type MapOrderByUidReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapOrderByUidReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapOrderByUidReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapOrderByUidReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapOrderByUidReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapOrderByUidReqValidationError) ErrorName() string { return "MapOrderByUidReqValidationError" }

// Error satisfies the builtin error interface
func (e MapOrderByUidReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapOrderByUidReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapOrderByUidReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapOrderByUidReqValidationError{}

// Validate checks the field values on MapOrderByUidResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapOrderByUidResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapOrderByUidResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapOrderByUidResponseMultiError, or nil if none found.
func (m *MapOrderByUidResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapOrderByUidResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetOrders()))
		i := 0
		for key := range m.GetOrders() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOrders()[key]
			_ = val

			// no validation rules for Orders[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapOrderByUidResponseValidationError{
							field:  fmt.Sprintf("Orders[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapOrderByUidResponseValidationError{
							field:  fmt.Sprintf("Orders[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapOrderByUidResponseValidationError{
						field:  fmt.Sprintf("Orders[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapOrderByUidResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapOrderByUidResponseValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapOrderByUidResponseValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MapOrderByUidResponseMultiError(errors)
	}

	return nil
}

// MapOrderByUidResponseMultiError is an error wrapping multiple validation
// errors returned by MapOrderByUidResponse.ValidateAll() if the designated
// constraints aren't met.
type MapOrderByUidResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapOrderByUidResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapOrderByUidResponseMultiError) AllErrors() []error { return m }

// MapOrderByUidResponseValidationError is the validation error returned by
// MapOrderByUidResponse.Validate if the designated constraints aren't met.
type MapOrderByUidResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapOrderByUidResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapOrderByUidResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapOrderByUidResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapOrderByUidResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapOrderByUidResponseValidationError) ErrorName() string {
	return "MapOrderByUidResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapOrderByUidResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapOrderByUidResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapOrderByUidResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapOrderByUidResponseValidationError{}

// Validate checks the field values on UpdateOrderStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOrderStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOrderStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOrderStateReqMultiError, or nil if none found.
func (m *UpdateOrderStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOrderStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Action

	// no validation rules for State

	if len(errors) > 0 {
		return UpdateOrderStateReqMultiError(errors)
	}

	return nil
}

// UpdateOrderStateReqMultiError is an error wrapping multiple validation
// errors returned by UpdateOrderStateReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateOrderStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOrderStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOrderStateReqMultiError) AllErrors() []error { return m }

// UpdateOrderStateReqValidationError is the validation error returned by
// UpdateOrderStateReq.Validate if the designated constraints aren't met.
type UpdateOrderStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOrderStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOrderStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOrderStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOrderStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOrderStateReqValidationError) ErrorName() string {
	return "UpdateOrderStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOrderStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOrderStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOrderStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOrderStateReqValidationError{}

// Validate checks the field values on UpdateOrderStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOrderStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOrderStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOrderStateResponseMultiError, or nil if none found.
func (m *UpdateOrderStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOrderStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return UpdateOrderStateResponseMultiError(errors)
	}

	return nil
}

// UpdateOrderStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateOrderStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateOrderStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOrderStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOrderStateResponseMultiError) AllErrors() []error { return m }

// UpdateOrderStateResponseValidationError is the validation error returned by
// UpdateOrderStateResponse.Validate if the designated constraints aren't met.
type UpdateOrderStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOrderStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOrderStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOrderStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOrderStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOrderStateResponseValidationError) ErrorName() string {
	return "UpdateOrderStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOrderStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOrderStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOrderStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOrderStateResponseValidationError{}
