// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: domain/user/v1/user.proto

package domainuserv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Password

	// no validation rules for Phone

	// no validation rules for Email

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on Info with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Info) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Info with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InfoMultiError, or nil if none found.
func (m *Info) ValidateAll() error {
	return m.validate(true)
}

func (m *Info) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Sex

	if all {
		switch v := interface{}(m.GetAvatar()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoValidationError{
					field:  "Avatar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoValidationError{
					field:  "Avatar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvatar()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoValidationError{
				field:  "Avatar",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sign

	// no validation rules for Rank

	// no validation rules for Level

	if len(errors) > 0 {
		return InfoMultiError(errors)
	}

	return nil
}

// InfoMultiError is an error wrapping multiple validation errors returned by
// Info.ValidateAll() if the designated constraints aren't met.
type InfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoMultiError) AllErrors() []error { return m }

// InfoValidationError is the validation error returned by Info.Validate if the
// designated constraints aren't met.
type InfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoValidationError) ErrorName() string { return "InfoValidationError" }

// Error satisfies the builtin error interface
func (e InfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoValidationError{}

// Validate checks the field values on Card with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Card) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Card with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CardMultiError, or nil if none found.
func (m *Card) ValidateAll() error {
	return m.validate(true)
}

func (m *Card) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Sex

	if all {
		switch v := interface{}(m.GetAvatar()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Avatar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Avatar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvatar()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardValidationError{
				field:  "Avatar",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sign

	// no validation rules for Rank

	// no validation rules for Level

	// no validation rules for Silence

	if all {
		switch v := interface{}(m.GetVip()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Vip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Vip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVip()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardValidationError{
				field:  "Vip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPendant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Pendant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Pendant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPendant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardValidationError{
				field:  "Pendant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNameplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Nameplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Nameplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNameplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardValidationError{
				field:  "Nameplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfficial()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Official",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CardValidationError{
					field:  "Official",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfficial()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CardValidationError{
				field:  "Official",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CardMultiError(errors)
	}

	return nil
}

// CardMultiError is an error wrapping multiple validation errors returned by
// Card.ValidateAll() if the designated constraints aren't met.
type CardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardMultiError) AllErrors() []error { return m }

// CardValidationError is the validation error returned by Card.Validate if the
// designated constraints aren't met.
type CardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardValidationError) ErrorName() string { return "CardValidationError" }

// Error satisfies the builtin error interface
func (e CardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardValidationError{}

// Validate checks the field values on Profile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Profile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Profile with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProfileMultiError, or nil if none found.
func (m *Profile) ValidateAll() error {
	return m.validate(true)
}

func (m *Profile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Sex

	if all {
		switch v := interface{}(m.GetAvatar()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Avatar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Avatar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvatar()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "Avatar",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sign

	// no validation rules for Rank

	// no validation rules for Level

	// no validation rules for JoinTime

	// no validation rules for Moral

	// no validation rules for Silence

	// no validation rules for EmailStatus

	// no validation rules for PhoneStatus

	// no validation rules for Identification

	if all {
		switch v := interface{}(m.GetVip()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Vip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Vip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVip()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "Vip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPendant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Pendant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Pendant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPendant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "Pendant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNameplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Nameplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Nameplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNameplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "Nameplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfficial()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Official",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileValidationError{
					field:  "Official",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfficial()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileValidationError{
				field:  "Official",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Birthday

	if len(errors) > 0 {
		return ProfileMultiError(errors)
	}

	return nil
}

// ProfileMultiError is an error wrapping multiple validation errors returned
// by Profile.ValidateAll() if the designated constraints aren't met.
type ProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileMultiError) AllErrors() []error { return m }

// ProfileValidationError is the validation error returned by Profile.Validate
// if the designated constraints aren't met.
type ProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileValidationError) ErrorName() string { return "ProfileValidationError" }

// Error satisfies the builtin error interface
func (e ProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileValidationError{}

// Validate checks the field values on LevelInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LevelInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LevelInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LevelInfoMultiError, or nil
// if none found.
func (m *LevelInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *LevelInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cur

	// no validation rules for Min

	// no validation rules for NowExp

	// no validation rules for NextExp

	if len(errors) > 0 {
		return LevelInfoMultiError(errors)
	}

	return nil
}

// LevelInfoMultiError is an error wrapping multiple validation errors returned
// by LevelInfo.ValidateAll() if the designated constraints aren't met.
type LevelInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LevelInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LevelInfoMultiError) AllErrors() []error { return m }

// LevelInfoValidationError is the validation error returned by
// LevelInfo.Validate if the designated constraints aren't met.
type LevelInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LevelInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LevelInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LevelInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LevelInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LevelInfoValidationError) ErrorName() string { return "LevelInfoValidationError" }

// Error satisfies the builtin error interface
func (e LevelInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLevelInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LevelInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LevelInfoValidationError{}

// Validate checks the field values on VipInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VipInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VipInfoMultiError, or nil if none found.
func (m *VipInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *VipInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for DueDate

	// no validation rules for VipPayType

	if len(errors) > 0 {
		return VipInfoMultiError(errors)
	}

	return nil
}

// VipInfoMultiError is an error wrapping multiple validation errors returned
// by VipInfo.ValidateAll() if the designated constraints aren't met.
type VipInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipInfoMultiError) AllErrors() []error { return m }

// VipInfoValidationError is the validation error returned by VipInfo.Validate
// if the designated constraints aren't met.
type VipInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipInfoValidationError) ErrorName() string { return "VipInfoValidationError" }

// Error satisfies the builtin error interface
func (e VipInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipInfoValidationError{}

// Validate checks the field values on PendantInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PendantInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PendantInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PendantInfoMultiError, or
// nil if none found.
func (m *PendantInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PendantInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pid

	// no validation rules for Name

	// no validation rules for Image

	// no validation rules for Expire

	if len(errors) > 0 {
		return PendantInfoMultiError(errors)
	}

	return nil
}

// PendantInfoMultiError is an error wrapping multiple validation errors
// returned by PendantInfo.ValidateAll() if the designated constraints aren't met.
type PendantInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PendantInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PendantInfoMultiError) AllErrors() []error { return m }

// PendantInfoValidationError is the validation error returned by
// PendantInfo.Validate if the designated constraints aren't met.
type PendantInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PendantInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PendantInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PendantInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PendantInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PendantInfoValidationError) ErrorName() string { return "PendantInfoValidationError" }

// Error satisfies the builtin error interface
func (e PendantInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPendantInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PendantInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PendantInfoValidationError{}

// Validate checks the field values on NameplateInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NameplateInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NameplateInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NameplateInfoMultiError, or
// nil if none found.
func (m *NameplateInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NameplateInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nid

	// no validation rules for Name

	// no validation rules for Image

	// no validation rules for ImageSmall

	// no validation rules for Level

	// no validation rules for Condition

	if len(errors) > 0 {
		return NameplateInfoMultiError(errors)
	}

	return nil
}

// NameplateInfoMultiError is an error wrapping multiple validation errors
// returned by NameplateInfo.ValidateAll() if the designated constraints
// aren't met.
type NameplateInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NameplateInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NameplateInfoMultiError) AllErrors() []error { return m }

// NameplateInfoValidationError is the validation error returned by
// NameplateInfo.Validate if the designated constraints aren't met.
type NameplateInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NameplateInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NameplateInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NameplateInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NameplateInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NameplateInfoValidationError) ErrorName() string { return "NameplateInfoValidationError" }

// Error satisfies the builtin error interface
func (e NameplateInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNameplateInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NameplateInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NameplateInfoValidationError{}

// Validate checks the field values on OfficialInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OfficialInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OfficialInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OfficialInfoMultiError, or
// nil if none found.
func (m *OfficialInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OfficialInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	// no validation rules for Title

	// no validation rules for Desc

	if len(errors) > 0 {
		return OfficialInfoMultiError(errors)
	}

	return nil
}

// OfficialInfoMultiError is an error wrapping multiple validation errors
// returned by OfficialInfo.ValidateAll() if the designated constraints aren't met.
type OfficialInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OfficialInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OfficialInfoMultiError) AllErrors() []error { return m }

// OfficialInfoValidationError is the validation error returned by
// OfficialInfo.Validate if the designated constraints aren't met.
type OfficialInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OfficialInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OfficialInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OfficialInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OfficialInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OfficialInfoValidationError) ErrorName() string { return "OfficialInfoValidationError" }

// Error satisfies the builtin error interface
func (e OfficialInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOfficialInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OfficialInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OfficialInfoValidationError{}

// Validate checks the field values on CreateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateUserReqMultiError, or
// nil if none found.
func (m *CreateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserReqValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserReqValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserReqValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserReqMultiError(errors)
	}

	return nil
}

// CreateUserReqMultiError is an error wrapping multiple validation errors
// returned by CreateUserReq.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReqMultiError) AllErrors() []error { return m }

// CreateUserReqValidationError is the validation error returned by
// CreateUserReq.Validate if the designated constraints aren't met.
type CreateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReqValidationError) ErrorName() string { return "CreateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReqValidationError{}

// Validate checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserResponseMultiError, or nil if none found.
func (m *CreateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	if len(errors) > 0 {
		return CreateUserResponseMultiError(errors)
	}

	return nil
}

// CreateUserResponseMultiError is an error wrapping multiple validation errors
// returned by CreateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserResponseMultiError) AllErrors() []error { return m }

// CreateUserResponseValidationError is the validation error returned by
// CreateUserResponse.Validate if the designated constraints aren't met.
type CreateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserResponseValidationError) ErrorName() string {
	return "CreateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserResponseValidationError{}

// Validate checks the field values on UpdateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateUserReqMultiError, or
// nil if none found.
func (m *UpdateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserReqValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserReqValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserReqValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserReqMultiError(errors)
	}

	return nil
}

// UpdateUserReqMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReqMultiError) AllErrors() []error { return m }

// UpdateUserReqValidationError is the validation error returned by
// UpdateUserReq.Validate if the designated constraints aren't met.
type UpdateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReqValidationError) ErrorName() string { return "UpdateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReqValidationError{}

// Validate checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserResponseMultiError, or nil if none found.
func (m *UpdateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateUserResponseMultiError(errors)
	}

	return nil
}

// UpdateUserResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserResponseMultiError) AllErrors() []error { return m }

// UpdateUserResponseValidationError is the validation error returned by
// UpdateUserResponse.Validate if the designated constraints aren't met.
type UpdateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserResponseValidationError) ErrorName() string {
	return "UpdateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserResponseValidationError{}

// Validate checks the field values on UpdatePasswordReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePasswordReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePasswordReqMultiError, or nil if none found.
func (m *UpdatePasswordReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := UpdatePasswordReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 6 {
		err := UpdatePasswordReqValidationError{
			field:  "Password",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RealIp

	if len(errors) > 0 {
		return UpdatePasswordReqMultiError(errors)
	}

	return nil
}

// UpdatePasswordReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePasswordReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePasswordReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordReqMultiError) AllErrors() []error { return m }

// UpdatePasswordReqValidationError is the validation error returned by
// UpdatePasswordReq.Validate if the designated constraints aren't met.
type UpdatePasswordReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordReqValidationError) ErrorName() string {
	return "UpdatePasswordReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordReqValidationError{}

// Validate checks the field values on GetUserInfoByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoByUidReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoByUidReqMultiError, or nil if none found.
func (m *GetUserInfoByUidReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoByUidReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := GetUserInfoByUidReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserInfoByUidReqMultiError(errors)
	}

	return nil
}

// GetUserInfoByUidReqMultiError is an error wrapping multiple validation
// errors returned by GetUserInfoByUidReq.ValidateAll() if the designated
// constraints aren't met.
type GetUserInfoByUidReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoByUidReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoByUidReqMultiError) AllErrors() []error { return m }

// GetUserInfoByUidReqValidationError is the validation error returned by
// GetUserInfoByUidReq.Validate if the designated constraints aren't met.
type GetUserInfoByUidReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoByUidReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoByUidReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoByUidReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoByUidReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoByUidReqValidationError) ErrorName() string {
	return "GetUserInfoByUidReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoByUidReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoByUidReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoByUidReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoByUidReqValidationError{}

// Validate checks the field values on GetUserInfoByUidResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoByUidResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoByUidResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoByUidResponseMultiError, or nil if none found.
func (m *GetUserInfoByUidResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoByUidResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserInfoByUidResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserInfoByUidResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserInfoByUidResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserInfoByUidResponseMultiError(errors)
	}

	return nil
}

// GetUserInfoByUidResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserInfoByUidResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserInfoByUidResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoByUidResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoByUidResponseMultiError) AllErrors() []error { return m }

// GetUserInfoByUidResponseValidationError is the validation error returned by
// GetUserInfoByUidResponse.Validate if the designated constraints aren't met.
type GetUserInfoByUidResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoByUidResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoByUidResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoByUidResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoByUidResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoByUidResponseValidationError) ErrorName() string {
	return "GetUserInfoByUidResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoByUidResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoByUidResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoByUidResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoByUidResponseValidationError{}

// Validate checks the field values on GetUserCardByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserCardByUidReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserCardByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserCardByUidReqMultiError, or nil if none found.
func (m *GetUserCardByUidReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserCardByUidReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := GetUserCardByUidReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserCardByUidReqMultiError(errors)
	}

	return nil
}

// GetUserCardByUidReqMultiError is an error wrapping multiple validation
// errors returned by GetUserCardByUidReq.ValidateAll() if the designated
// constraints aren't met.
type GetUserCardByUidReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserCardByUidReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserCardByUidReqMultiError) AllErrors() []error { return m }

// GetUserCardByUidReqValidationError is the validation error returned by
// GetUserCardByUidReq.Validate if the designated constraints aren't met.
type GetUserCardByUidReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserCardByUidReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserCardByUidReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserCardByUidReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserCardByUidReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserCardByUidReqValidationError) ErrorName() string {
	return "GetUserCardByUidReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserCardByUidReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserCardByUidReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserCardByUidReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserCardByUidReqValidationError{}

// Validate checks the field values on GetUserProfileByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileByUidReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileByUidReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileByUidReqMultiError, or nil if none found.
func (m *GetUserProfileByUidReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileByUidReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := GetUserProfileByUidReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserProfileByUidReqMultiError(errors)
	}

	return nil
}

// GetUserProfileByUidReqMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileByUidReq.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileByUidReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileByUidReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileByUidReqMultiError) AllErrors() []error { return m }

// GetUserProfileByUidReqValidationError is the validation error returned by
// GetUserProfileByUidReq.Validate if the designated constraints aren't met.
type GetUserProfileByUidReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileByUidReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileByUidReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileByUidReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileByUidReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileByUidReqValidationError) ErrorName() string {
	return "GetUserProfileByUidReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileByUidReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileByUidReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileByUidReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileByUidReqValidationError{}

// Validate checks the field values on MapUserInfoByUidsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapUserInfoByUidsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapUserInfoByUidsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapUserInfoByUidsReqMultiError, or nil if none found.
func (m *MapUserInfoByUidsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapUserInfoByUidsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUids() {
		_, _ = idx, item

		if item <= 0 {
			err := MapUserInfoByUidsReqValidationError{
				field:  fmt.Sprintf("Uids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return MapUserInfoByUidsReqMultiError(errors)
	}

	return nil
}

// MapUserInfoByUidsReqMultiError is an error wrapping multiple validation
// errors returned by MapUserInfoByUidsReq.ValidateAll() if the designated
// constraints aren't met.
type MapUserInfoByUidsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapUserInfoByUidsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapUserInfoByUidsReqMultiError) AllErrors() []error { return m }

// MapUserInfoByUidsReqValidationError is the validation error returned by
// MapUserInfoByUidsReq.Validate if the designated constraints aren't met.
type MapUserInfoByUidsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapUserInfoByUidsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapUserInfoByUidsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapUserInfoByUidsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapUserInfoByUidsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapUserInfoByUidsReqValidationError) ErrorName() string {
	return "MapUserInfoByUidsReqValidationError"
}

// Error satisfies the builtin error interface
func (e MapUserInfoByUidsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapUserInfoByUidsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapUserInfoByUidsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapUserInfoByUidsReqValidationError{}

// Validate checks the field values on MapUserInfoByUidsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MapUserInfoByUidsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapUserInfoByUidsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapUserInfoByUidsResponseMultiError, or nil if none found.
func (m *MapUserInfoByUidsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MapUserInfoByUidsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetInfos()))
		i := 0
		for key := range m.GetInfos() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetInfos()[key]
			_ = val

			// no validation rules for Infos[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapUserInfoByUidsResponseValidationError{
							field:  fmt.Sprintf("Infos[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapUserInfoByUidsResponseValidationError{
							field:  fmt.Sprintf("Infos[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapUserInfoByUidsResponseValidationError{
						field:  fmt.Sprintf("Infos[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return MapUserInfoByUidsResponseMultiError(errors)
	}

	return nil
}

// MapUserInfoByUidsResponseMultiError is an error wrapping multiple validation
// errors returned by MapUserInfoByUidsResponse.ValidateAll() if the
// designated constraints aren't met.
type MapUserInfoByUidsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapUserInfoByUidsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapUserInfoByUidsResponseMultiError) AllErrors() []error { return m }

// MapUserInfoByUidsResponseValidationError is the validation error returned by
// MapUserInfoByUidsResponse.Validate if the designated constraints aren't met.
type MapUserInfoByUidsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapUserInfoByUidsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapUserInfoByUidsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapUserInfoByUidsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapUserInfoByUidsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapUserInfoByUidsResponseValidationError) ErrorName() string {
	return "MapUserInfoByUidsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MapUserInfoByUidsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapUserInfoByUidsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapUserInfoByUidsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapUserInfoByUidsResponseValidationError{}

// Validate checks the field values on NamesReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamesReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamesReqMultiError, or nil
// if none found.
func (m *NamesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NamesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNames() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 4 {
			err := NamesReqValidationError{
				field:  fmt.Sprintf("Names[%v]", idx),
				reason: "value length must be at least 4 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for RealIp

	if len(errors) > 0 {
		return NamesReqMultiError(errors)
	}

	return nil
}

// NamesReqMultiError is an error wrapping multiple validation errors returned
// by NamesReq.ValidateAll() if the designated constraints aren't met.
type NamesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamesReqMultiError) AllErrors() []error { return m }

// NamesReqValidationError is the validation error returned by
// NamesReq.Validate if the designated constraints aren't met.
type NamesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamesReqValidationError) ErrorName() string { return "NamesReqValidationError" }

// Error satisfies the builtin error interface
func (e NamesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamesReqValidationError{}

// Validate checks the field values on ExpReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExpReqMultiError, or nil if none found.
func (m *ExpReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := ExpReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Exp

	// no validation rules for Operater

	// no validation rules for Operate

	// no validation rules for Reason

	// no validation rules for RealIp

	if len(errors) > 0 {
		return ExpReqMultiError(errors)
	}

	return nil
}

// ExpReqMultiError is an error wrapping multiple validation errors returned by
// ExpReq.ValidateAll() if the designated constraints aren't met.
type ExpReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpReqMultiError) AllErrors() []error { return m }

// ExpReqValidationError is the validation error returned by ExpReq.Validate if
// the designated constraints aren't met.
type ExpReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpReqValidationError) ErrorName() string { return "ExpReqValidationError" }

// Error satisfies the builtin error interface
func (e ExpReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpReqValidationError{}

// Validate checks the field values on MoralReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MoralReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoralReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MoralReqMultiError, or nil
// if none found.
func (m *MoralReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MoralReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := MoralReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Moral

	// no validation rules for Oper

	// no validation rules for Reason

	// no validation rules for Remark

	// no validation rules for RealIp

	if len(errors) > 0 {
		return MoralReqMultiError(errors)
	}

	return nil
}

// MoralReqMultiError is an error wrapping multiple validation errors returned
// by MoralReq.ValidateAll() if the designated constraints aren't met.
type MoralReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoralReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoralReqMultiError) AllErrors() []error { return m }

// MoralReqValidationError is the validation error returned by
// MoralReq.Validate if the designated constraints aren't met.
type MoralReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoralReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoralReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoralReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoralReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoralReqValidationError) ErrorName() string { return "MoralReqValidationError" }

// Error satisfies the builtin error interface
func (e MoralReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoralReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoralReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoralReqValidationError{}

// Validate checks the field values on RelationReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RelationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RelationReqMultiError, or
// nil if none found.
func (m *RelationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := RelationReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OwnerUid

	// no validation rules for RealIp

	if len(errors) > 0 {
		return RelationReqMultiError(errors)
	}

	return nil
}

// RelationReqMultiError is an error wrapping multiple validation errors
// returned by RelationReq.ValidateAll() if the designated constraints aren't met.
type RelationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationReqMultiError) AllErrors() []error { return m }

// RelationReqValidationError is the validation error returned by
// RelationReq.Validate if the designated constraints aren't met.
type RelationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationReqValidationError) ErrorName() string { return "RelationReqValidationError" }

// Error satisfies the builtin error interface
func (e RelationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationReqValidationError{}

// Validate checks the field values on RelationsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RelationsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RelationsReqMultiError, or
// nil if none found.
func (m *RelationsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := RelationsReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RealIp

	if len(errors) > 0 {
		return RelationsReqMultiError(errors)
	}

	return nil
}

// RelationsReqMultiError is an error wrapping multiple validation errors
// returned by RelationsReq.ValidateAll() if the designated constraints aren't met.
type RelationsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationsReqMultiError) AllErrors() []error { return m }

// RelationsReqValidationError is the validation error returned by
// RelationsReq.Validate if the designated constraints aren't met.
type RelationsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationsReqValidationError) ErrorName() string { return "RelationsReqValidationError" }

// Error satisfies the builtin error interface
func (e RelationsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationsReqValidationError{}

// Validate checks the field values on RichRelationReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RichRelationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RichRelationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RichRelationReqMultiError, or nil if none found.
func (m *RichRelationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RichRelationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUid

	for idx, item := range m.GetUids() {
		_, _ = idx, item

		if item <= 0 {
			err := RichRelationReqValidationError{
				field:  fmt.Sprintf("Uids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for RealIp

	if len(errors) > 0 {
		return RichRelationReqMultiError(errors)
	}

	return nil
}

// RichRelationReqMultiError is an error wrapping multiple validation errors
// returned by RichRelationReq.ValidateAll() if the designated constraints
// aren't met.
type RichRelationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RichRelationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RichRelationReqMultiError) AllErrors() []error { return m }

// RichRelationReqValidationError is the validation error returned by
// RichRelationReq.Validate if the designated constraints aren't met.
type RichRelationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RichRelationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RichRelationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RichRelationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RichRelationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RichRelationReqValidationError) ErrorName() string { return "RichRelationReqValidationError" }

// Error satisfies the builtin error interface
func (e RichRelationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRichRelationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RichRelationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RichRelationReqValidationError{}

// Validate checks the field values on UpdateProfileReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateProfileReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProfileReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProfileReqMultiError, or nil if none found.
func (m *UpdateProfileReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProfileReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProfileReqValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProfileReqValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProfileReqValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateProfileReqMultiError(errors)
	}

	return nil
}

// UpdateProfileReqMultiError is an error wrapping multiple validation errors
// returned by UpdateProfileReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateProfileReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProfileReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProfileReqMultiError) AllErrors() []error { return m }

// UpdateProfileReqValidationError is the validation error returned by
// UpdateProfileReq.Validate if the designated constraints aren't met.
type UpdateProfileReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProfileReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProfileReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProfileReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProfileReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProfileReqValidationError) ErrorName() string { return "UpdateProfileReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateProfileReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProfileReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProfileReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProfileReqValidationError{}

// Validate checks the field values on UpdateProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProfileResponseMultiError, or nil if none found.
func (m *UpdateProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateProfileResponseMultiError(errors)
	}

	return nil
}

// UpdateProfileResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateProfileResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProfileResponseMultiError) AllErrors() []error { return m }

// UpdateProfileResponseValidationError is the validation error returned by
// UpdateProfileResponse.Validate if the designated constraints aren't met.
type UpdateProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProfileResponseValidationError) ErrorName() string {
	return "UpdateProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProfileResponseValidationError{}

// Validate checks the field values on GetUserProfileByUidResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileByUidResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileByUidResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileByUidResponseMultiError, or nil if none found.
func (m *GetUserProfileByUidResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileByUidResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserProfileByUidResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserProfileByUidResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserProfileByUidResponseValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserProfileByUidResponseMultiError(errors)
	}

	return nil
}

// GetUserProfileByUidResponseMultiError is an error wrapping multiple
// validation errors returned by GetUserProfileByUidResponse.ValidateAll() if
// the designated constraints aren't met.
type GetUserProfileByUidResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileByUidResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileByUidResponseMultiError) AllErrors() []error { return m }

// GetUserProfileByUidResponseValidationError is the validation error returned
// by GetUserProfileByUidResponse.Validate if the designated constraints
// aren't met.
type GetUserProfileByUidResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileByUidResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileByUidResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileByUidResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileByUidResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileByUidResponseValidationError) ErrorName() string {
	return "GetUserProfileByUidResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileByUidResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileByUidResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileByUidResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileByUidResponseValidationError{}

// Validate checks the field values on GetUserCardByUidResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserCardByUidResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserCardByUidResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserCardByUidResponseMultiError, or nil if none found.
func (m *GetUserCardByUidResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserCardByUidResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserCardByUidResponseValidationError{
					field:  "Card",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserCardByUidResponseValidationError{
					field:  "Card",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserCardByUidResponseValidationError{
				field:  "Card",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserCardByUidResponseMultiError(errors)
	}

	return nil
}

// GetUserCardByUidResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserCardByUidResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserCardByUidResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserCardByUidResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserCardByUidResponseMultiError) AllErrors() []error { return m }

// GetUserCardByUidResponseValidationError is the validation error returned by
// GetUserCardByUidResponse.Validate if the designated constraints aren't met.
type GetUserCardByUidResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserCardByUidResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserCardByUidResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserCardByUidResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserCardByUidResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserCardByUidResponseValidationError) ErrorName() string {
	return "GetUserCardByUidResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserCardByUidResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserCardByUidResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserCardByUidResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserCardByUidResponseValidationError{}

// Validate checks the field values on CardsResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CardsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CardsResponseMultiError, or
// nil if none found.
func (m *CardsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CardsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetCards()))
		i := 0
		for key := range m.GetCards() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCards()[key]
			_ = val

			// no validation rules for Cards[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CardsResponseValidationError{
							field:  fmt.Sprintf("Cards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CardsResponseValidationError{
							field:  fmt.Sprintf("Cards[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CardsResponseValidationError{
						field:  fmt.Sprintf("Cards[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return CardsResponseMultiError(errors)
	}

	return nil
}

// CardsResponseMultiError is an error wrapping multiple validation errors
// returned by CardsResponse.ValidateAll() if the designated constraints
// aren't met.
type CardsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardsResponseMultiError) AllErrors() []error { return m }

// CardsResponseValidationError is the validation error returned by
// CardsResponse.Validate if the designated constraints aren't met.
type CardsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardsResponseValidationError) ErrorName() string { return "CardsResponseValidationError" }

// Error satisfies the builtin error interface
func (e CardsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardsResponseValidationError{}

// Validate checks the field values on ProfileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProfileResponseMultiError, or nil if none found.
func (m *ProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileResponseValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProfileResponseMultiError(errors)
	}

	return nil
}

// ProfileResponseMultiError is an error wrapping multiple validation errors
// returned by ProfileResponse.ValidateAll() if the designated constraints
// aren't met.
type ProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileResponseMultiError) AllErrors() []error { return m }

// ProfileResponseValidationError is the validation error returned by
// ProfileResponse.Validate if the designated constraints aren't met.
type ProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileResponseValidationError) ErrorName() string { return "ProfileResponseValidationError" }

// Error satisfies the builtin error interface
func (e ProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileResponseValidationError{}

// Validate checks the field values on ProfileStatResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProfileStatResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProfileStatResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProfileStatResponseMultiError, or nil if none found.
func (m *ProfileStatResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProfileStatResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileStatResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileStatResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileStatResponseValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLevelInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfileStatResponseValidationError{
					field:  "LevelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfileStatResponseValidationError{
					field:  "LevelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLevelInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfileStatResponseValidationError{
				field:  "LevelInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Coins

	// no validation rules for Following

	// no validation rules for Follower

	if len(errors) > 0 {
		return ProfileStatResponseMultiError(errors)
	}

	return nil
}

// ProfileStatResponseMultiError is an error wrapping multiple validation
// errors returned by ProfileStatResponse.ValidateAll() if the designated
// constraints aren't met.
type ProfileStatResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileStatResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileStatResponseMultiError) AllErrors() []error { return m }

// ProfileStatResponseValidationError is the validation error returned by
// ProfileStatResponse.Validate if the designated constraints aren't met.
type ProfileStatResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileStatResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileStatResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileStatResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileStatResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileStatResponseValidationError) ErrorName() string {
	return "ProfileStatResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProfileStatResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfileStatResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileStatResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileStatResponseValidationError{}

// Validate checks the field values on RelationResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationResponseMultiError, or nil if none found.
func (m *RelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Following

	if len(errors) > 0 {
		return RelationResponseMultiError(errors)
	}

	return nil
}

// RelationResponseMultiError is an error wrapping multiple validation errors
// returned by RelationResponse.ValidateAll() if the designated constraints
// aren't met.
type RelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationResponseMultiError) AllErrors() []error { return m }

// RelationResponseValidationError is the validation error returned by
// RelationResponse.Validate if the designated constraints aren't met.
type RelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationResponseValidationError) ErrorName() string { return "RelationResponseValidationError" }

// Error satisfies the builtin error interface
func (e RelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationResponseValidationError{}

// Validate checks the field values on AttentionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttentionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttentionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttentionsResponseMultiError, or nil if none found.
func (m *AttentionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AttentionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AttentionsResponseMultiError(errors)
	}

	return nil
}

// AttentionsResponseMultiError is an error wrapping multiple validation errors
// returned by AttentionsResponse.ValidateAll() if the designated constraints
// aren't met.
type AttentionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttentionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttentionsResponseMultiError) AllErrors() []error { return m }

// AttentionsResponseValidationError is the validation error returned by
// AttentionsResponse.Validate if the designated constraints aren't met.
type AttentionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttentionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttentionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttentionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttentionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttentionsResponseValidationError) ErrorName() string {
	return "AttentionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AttentionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttentionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttentionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttentionsResponseValidationError{}

// Validate checks the field values on BlacksResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlacksResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlacksResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlacksResponseMultiError,
// or nil if none found.
func (m *BlacksResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BlacksResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlackList

	if len(errors) > 0 {
		return BlacksResponseMultiError(errors)
	}

	return nil
}

// BlacksResponseMultiError is an error wrapping multiple validation errors
// returned by BlacksResponse.ValidateAll() if the designated constraints
// aren't met.
type BlacksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlacksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlacksResponseMultiError) AllErrors() []error { return m }

// BlacksResponseValidationError is the validation error returned by
// BlacksResponse.Validate if the designated constraints aren't met.
type BlacksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlacksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlacksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlacksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlacksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlacksResponseValidationError) ErrorName() string { return "BlacksResponseValidationError" }

// Error satisfies the builtin error interface
func (e BlacksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlacksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlacksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlacksResponseValidationError{}

// Validate checks the field values on RelationsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RelationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationsResponseMultiError, or nil if none found.
func (m *RelationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetRelations()))
		i := 0
		for key := range m.GetRelations() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRelations()[key]
			_ = val

			// no validation rules for Relations[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RelationsResponseValidationError{
							field:  fmt.Sprintf("Relations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RelationsResponseValidationError{
							field:  fmt.Sprintf("Relations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RelationsResponseValidationError{
						field:  fmt.Sprintf("Relations[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return RelationsResponseMultiError(errors)
	}

	return nil
}

// RelationsResponseMultiError is an error wrapping multiple validation errors
// returned by RelationsResponse.ValidateAll() if the designated constraints
// aren't met.
type RelationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationsResponseMultiError) AllErrors() []error { return m }

// RelationsResponseValidationError is the validation error returned by
// RelationsResponse.Validate if the designated constraints aren't met.
type RelationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationsResponseValidationError) ErrorName() string {
	return "RelationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RelationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationsResponseValidationError{}

// Validate checks the field values on RichRelationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RichRelationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RichRelationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RichRelationsResponseMultiError, or nil if none found.
func (m *RichRelationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RichRelationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RichRelations

	if len(errors) > 0 {
		return RichRelationsResponseMultiError(errors)
	}

	return nil
}

// RichRelationsResponseMultiError is an error wrapping multiple validation
// errors returned by RichRelationsResponse.ValidateAll() if the designated
// constraints aren't met.
type RichRelationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RichRelationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RichRelationsResponseMultiError) AllErrors() []error { return m }

// RichRelationsResponseValidationError is the validation error returned by
// RichRelationsResponse.Validate if the designated constraints aren't met.
type RichRelationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RichRelationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RichRelationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RichRelationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RichRelationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RichRelationsResponseValidationError) ErrorName() string {
	return "RichRelationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RichRelationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRichRelationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RichRelationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RichRelationsResponseValidationError{}

// Validate checks the field values on VipResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VipResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VipResponseMultiError, or
// nil if none found.
func (m *VipResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VipResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for DueDate

	// no validation rules for VipPayType

	if len(errors) > 0 {
		return VipResponseMultiError(errors)
	}

	return nil
}

// VipResponseMultiError is an error wrapping multiple validation errors
// returned by VipResponse.ValidateAll() if the designated constraints aren't met.
type VipResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipResponseMultiError) AllErrors() []error { return m }

// VipResponseValidationError is the validation error returned by
// VipResponse.Validate if the designated constraints aren't met.
type VipResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipResponseValidationError) ErrorName() string { return "VipResponseValidationError" }

// Error satisfies the builtin error interface
func (e VipResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipResponseValidationError{}

// Validate checks the field values on VipsResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VipsResponseMultiError, or
// nil if none found.
func (m *VipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetVips()))
		i := 0
		for key := range m.GetVips() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetVips()[key]
			_ = val

			// no validation rules for Vips[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, VipsResponseValidationError{
							field:  fmt.Sprintf("Vips[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, VipsResponseValidationError{
							field:  fmt.Sprintf("Vips[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return VipsResponseValidationError{
						field:  fmt.Sprintf("Vips[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return VipsResponseMultiError(errors)
	}

	return nil
}

// VipsResponseMultiError is an error wrapping multiple validation errors
// returned by VipsResponse.ValidateAll() if the designated constraints aren't met.
type VipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipsResponseMultiError) AllErrors() []error { return m }

// VipsResponseValidationError is the validation error returned by
// VipsResponse.Validate if the designated constraints aren't met.
type VipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipsResponseValidationError) ErrorName() string { return "VipsResponseValidationError" }

// Error satisfies the builtin error interface
func (e VipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipsResponseValidationError{}

// Validate checks the field values on ExpResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpResponseMultiError, or
// nil if none found.
func (m *ExpResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExpResponseMultiError(errors)
	}

	return nil
}

// ExpResponseMultiError is an error wrapping multiple validation errors
// returned by ExpResponse.ValidateAll() if the designated constraints aren't met.
type ExpResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpResponseMultiError) AllErrors() []error { return m }

// ExpResponseValidationError is the validation error returned by
// ExpResponse.Validate if the designated constraints aren't met.
type ExpResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpResponseValidationError) ErrorName() string { return "ExpResponseValidationError" }

// Error satisfies the builtin error interface
func (e ExpResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpResponseValidationError{}

// Validate checks the field values on MoralResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MoralResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoralResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MoralResponseMultiError, or
// nil if none found.
func (m *MoralResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MoralResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MoralResponseMultiError(errors)
	}

	return nil
}

// MoralResponseMultiError is an error wrapping multiple validation errors
// returned by MoralResponse.ValidateAll() if the designated constraints
// aren't met.
type MoralResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoralResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoralResponseMultiError) AllErrors() []error { return m }

// MoralResponseValidationError is the validation error returned by
// MoralResponse.Validate if the designated constraints aren't met.
type MoralResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoralResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoralResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoralResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoralResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoralResponseValidationError) ErrorName() string { return "MoralResponseValidationError" }

// Error satisfies the builtin error interface
func (e MoralResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoralResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoralResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoralResponseValidationError{}
