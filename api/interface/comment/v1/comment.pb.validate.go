// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: interface/comment/v1/comment.proto

package commentv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Subject with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subject with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubjectMultiError, or nil if none found.
func (m *Subject) ValidateAll() error {
	return m.validate(true)
}

func (m *Subject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) > 32 {
		err := SubjectValidationError{
			field:  "Id",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOwnerUid()) > 32 {
		err := SubjectValidationError{
			field:  "OwnerUid",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBelongId()) > 32 {
		err := SubjectValidationError{
			field:  "BelongId",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBizType()) > 32 {
		err := SubjectValidationError{
			field:  "BizType",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCreatedAt() < 0 {
		err := SubjectValidationError{
			field:  "CreatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdatedAt() < 0 {
		err := SubjectValidationError{
			field:  "UpdatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFloorCount() < 0 {
		err := SubjectValidationError{
			field:  "FloorCount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetReplyCount() < 0 {
		err := SubjectValidationError{
			field:  "ReplyCount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for State

	// no validation rules for Attr

	// no validation rules for Meta

	if len(errors) > 0 {
		return SubjectMultiError(errors)
	}

	return nil
}

// SubjectMultiError is an error wrapping multiple validation errors returned
// by Subject.ValidateAll() if the designated constraints aren't met.
type SubjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubjectMultiError) AllErrors() []error { return m }

// SubjectValidationError is the validation error returned by Subject.Validate
// if the designated constraints aren't met.
type SubjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubjectValidationError) ErrorName() string { return "SubjectValidationError" }

// Error satisfies the builtin error interface
func (e SubjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubjectValidationError{}

// Validate checks the field values on FloorAttr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FloorAttr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FloorAttr with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FloorAttrMultiError, or nil
// if none found.
func (m *FloorAttr) ValidateAll() error {
	return m.validate(true)
}

func (m *FloorAttr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetReplyCount() < 0 {
		err := FloorAttrValidationError{
			field:  "ReplyCount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPinAdmin() < 0 {
		err := FloorAttrValidationError{
			field:  "PinAdmin",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPinOwner() < 0 {
		err := FloorAttrValidationError{
			field:  "PinOwner",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Fold

	// no validation rules for Hot

	if len(errors) > 0 {
		return FloorAttrMultiError(errors)
	}

	return nil
}

// FloorAttrMultiError is an error wrapping multiple validation errors returned
// by FloorAttr.ValidateAll() if the designated constraints aren't met.
type FloorAttrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FloorAttrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FloorAttrMultiError) AllErrors() []error { return m }

// FloorAttrValidationError is the validation error returned by
// FloorAttr.Validate if the designated constraints aren't met.
type FloorAttrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FloorAttrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FloorAttrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FloorAttrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FloorAttrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FloorAttrValidationError) ErrorName() string { return "FloorAttrValidationError" }

// Error satisfies the builtin error interface
func (e FloorAttrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFloorAttr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FloorAttrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FloorAttrValidationError{}

// Validate checks the field values on Reply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Reply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Reply with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReplyMultiError, or nil if none found.
func (m *Reply) ValidateAll() error {
	return m.validate(true)
}

func (m *Reply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if utf8.RuneCountInString(m.GetOwnerUid()) > 32 {
		err := ReplyValidationError{
			field:  "OwnerUid",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSubjectId()) > 32 {
		err := ReplyValidationError{
			field:  "SubjectId",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBizType()) > 32 {
		err := ReplyValidationError{
			field:  "BizType",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFloorId()) > 32 {
		err := ReplyValidationError{
			field:  "FloorId",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Content

	if utf8.RuneCountInString(m.GetAtUid()) > 32 {
		err := ReplyValidationError{
			field:  "AtUid",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for State

	if m.GetCreatedAt() < 0 {
		err := ReplyValidationError{
			field:  "CreatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdatedAt() < 0 {
		err := ReplyValidationError{
			field:  "UpdatedAt",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Deleted

	if m.GetLikeCount() < 0 {
		err := ReplyValidationError{
			field:  "LikeCount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDislikeCount() < 0 {
		err := ReplyValidationError{
			field:  "DislikeCount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Dialog

	// no validation rules for FanGrade

	// no validation rules for Platform

	// no validation rules for Device

	// no validation rules for Attr

	if all {
		switch v := interface{}(m.GetFloorAttr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "FloorAttr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "FloorAttr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFloorAttr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReplyValidationError{
				field:  "FloorAttr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReplyValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAtUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "AtUserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReplyValidationError{
					field:  "AtUserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReplyValidationError{
				field:  "AtUserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReplyMultiError(errors)
	}

	return nil
}

// ReplyMultiError is an error wrapping multiple validation errors returned by
// Reply.ValidateAll() if the designated constraints aren't met.
type ReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplyMultiError) AllErrors() []error { return m }

// ReplyValidationError is the validation error returned by Reply.Validate if
// the designated constraints aren't met.
type ReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplyValidationError) ErrorName() string { return "ReplyValidationError" }

// Error satisfies the builtin error interface
func (e ReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplyValidationError{}

// Validate checks the field values on Floor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Floor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Floor with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FloorMultiError, or nil if none found.
func (m *Floor) ValidateAll() error {
	return m.validate(true)
}

func (m *Floor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRootReply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "RootReply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "RootReply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootReply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FloorValidationError{
				field:  "RootReply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FloorValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FloorValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FloorValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FloorValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FloorValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FloorMultiError(errors)
	}

	return nil
}

// FloorMultiError is an error wrapping multiple validation errors returned by
// Floor.ValidateAll() if the designated constraints aren't met.
type FloorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FloorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FloorMultiError) AllErrors() []error { return m }

// FloorValidationError is the validation error returned by Floor.Validate if
// the designated constraints aren't met.
type FloorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FloorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FloorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FloorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FloorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FloorValidationError) ErrorName() string { return "FloorValidationError" }

// Error satisfies the builtin error interface
func (e FloorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFloor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FloorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FloorValidationError{}

// Validate checks the field values on CreateSubjectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateSubjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubjectReqMultiError, or nil if none found.
func (m *CreateSubjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBelongId() < 0 {
		err := CreateSubjectReqValidationError{
			field:  "BelongId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBizType()) > 32 {
		err := CreateSubjectReqValidationError{
			field:  "BizType",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOwnerUid() < 0 {
		err := CreateSubjectReqValidationError{
			field:  "OwnerUid",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateSubjectReqMultiError(errors)
	}

	return nil
}

// CreateSubjectReqMultiError is an error wrapping multiple validation errors
// returned by CreateSubjectReq.ValidateAll() if the designated constraints
// aren't met.
type CreateSubjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubjectReqMultiError) AllErrors() []error { return m }

// CreateSubjectReqValidationError is the validation error returned by
// CreateSubjectReq.Validate if the designated constraints aren't met.
type CreateSubjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubjectReqValidationError) ErrorName() string { return "CreateSubjectReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateSubjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubjectReqValidationError{}

// Validate checks the field values on CreateSubjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubjectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubjectResponseMultiError, or nil if none found.
func (m *CreateSubjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSubjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSubjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSubjectResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSubjectResponseMultiError(errors)
	}

	return nil
}

// CreateSubjectResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSubjectResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSubjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubjectResponseMultiError) AllErrors() []error { return m }

// CreateSubjectResponseValidationError is the validation error returned by
// CreateSubjectResponse.Validate if the designated constraints aren't met.
type CreateSubjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubjectResponseValidationError) ErrorName() string {
	return "CreateSubjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubjectResponseValidationError{}

// Validate checks the field values on GetSubjectByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByIdReqMultiError, or nil if none found.
func (m *GetSubjectByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubjectId() < 0 {
		err := GetSubjectByIdReqValidationError{
			field:  "SubjectId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSubjectByIdReqMultiError(errors)
	}

	return nil
}

// GetSubjectByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetSubjectByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetSubjectByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByIdReqMultiError) AllErrors() []error { return m }

// GetSubjectByIdReqValidationError is the validation error returned by
// GetSubjectByIdReq.Validate if the designated constraints aren't met.
type GetSubjectByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByIdReqValidationError) ErrorName() string {
	return "GetSubjectByIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByIdReqValidationError{}

// Validate checks the field values on GetSubjectByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByIdResponseMultiError, or nil if none found.
func (m *GetSubjectByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubjectByIdResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubjectByIdResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubjectByIdResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubjectByIdResponseMultiError(errors)
	}

	return nil
}

// GetSubjectByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetSubjectByIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSubjectByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByIdResponseMultiError) AllErrors() []error { return m }

// GetSubjectByIdResponseValidationError is the validation error returned by
// GetSubjectByIdResponse.Validate if the designated constraints aren't met.
type GetSubjectByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByIdResponseValidationError) ErrorName() string {
	return "GetSubjectByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByIdResponseValidationError{}

// Validate checks the field values on GetSubjectByBelongReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByBelongReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByBelongReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByBelongReqMultiError, or nil if none found.
func (m *GetSubjectByBelongReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByBelongReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBelongId() < 0 {
		err := GetSubjectByBelongReqValidationError{
			field:  "BelongId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBizType()) > 32 {
		err := GetSubjectByBelongReqValidationError{
			field:  "BizType",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSubjectByBelongReqMultiError(errors)
	}

	return nil
}

// GetSubjectByBelongReqMultiError is an error wrapping multiple validation
// errors returned by GetSubjectByBelongReq.ValidateAll() if the designated
// constraints aren't met.
type GetSubjectByBelongReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByBelongReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByBelongReqMultiError) AllErrors() []error { return m }

// GetSubjectByBelongReqValidationError is the validation error returned by
// GetSubjectByBelongReq.Validate if the designated constraints aren't met.
type GetSubjectByBelongReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByBelongReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByBelongReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByBelongReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByBelongReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByBelongReqValidationError) ErrorName() string {
	return "GetSubjectByBelongReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByBelongReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByBelongReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByBelongReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByBelongReqValidationError{}

// Validate checks the field values on GetSubjectByBelongResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByBelongResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByBelongResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByBelongResponseMultiError, or nil if none found.
func (m *GetSubjectByBelongResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByBelongResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubjectByBelongResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubjectByBelongResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubjectByBelongResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubjectByBelongResponseMultiError(errors)
	}

	return nil
}

// GetSubjectByBelongResponseMultiError is an error wrapping multiple
// validation errors returned by GetSubjectByBelongResponse.ValidateAll() if
// the designated constraints aren't met.
type GetSubjectByBelongResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByBelongResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByBelongResponseMultiError) AllErrors() []error { return m }

// GetSubjectByBelongResponseValidationError is the validation error returned
// by GetSubjectByBelongResponse.Validate if the designated constraints aren't met.
type GetSubjectByBelongResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByBelongResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByBelongResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByBelongResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByBelongResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByBelongResponseValidationError) ErrorName() string {
	return "GetSubjectByBelongResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByBelongResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByBelongResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByBelongResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByBelongResponseValidationError{}

// Validate checks the field values on CreateReplyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateReplyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateReplyReqMultiError,
// or nil if none found.
func (m *CreateReplyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsFloor

	// no validation rules for Uid

	if m.GetSubjectId() < 0 {
		err := CreateReplyReqValidationError{
			field:  "SubjectId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBizType()) > 32 {
		err := CreateReplyReqValidationError{
			field:  "BizType",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFloorId() < 0 {
		err := CreateReplyReqValidationError{
			field:  "FloorId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Content

	if m.GetAtUid() < 0 {
		err := CreateReplyReqValidationError{
			field:  "AtUid",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateReplyReqMultiError(errors)
	}

	return nil
}

// CreateReplyReqMultiError is an error wrapping multiple validation errors
// returned by CreateReplyReq.ValidateAll() if the designated constraints
// aren't met.
type CreateReplyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplyReqMultiError) AllErrors() []error { return m }

// CreateReplyReqValidationError is the validation error returned by
// CreateReplyReq.Validate if the designated constraints aren't met.
type CreateReplyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplyReqValidationError) ErrorName() string { return "CreateReplyReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateReplyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplyReqValidationError{}

// Validate checks the field values on CreateReplyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReplyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateReplyResponseMultiError, or nil if none found.
func (m *CreateReplyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateReplyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateReplyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateReplyResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateReplyResponseMultiError(errors)
	}

	return nil
}

// CreateReplyResponseMultiError is an error wrapping multiple validation
// errors returned by CreateReplyResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateReplyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplyResponseMultiError) AllErrors() []error { return m }

// CreateReplyResponseValidationError is the validation error returned by
// CreateReplyResponse.Validate if the designated constraints aren't met.
type CreateReplyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplyResponseValidationError) ErrorName() string {
	return "CreateReplyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReplyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplyResponseValidationError{}

// Validate checks the field values on ListFloorBySubjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListFloorBySubjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectReqMultiError, or nil if none found.
func (m *ListFloorBySubjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 0 {
		err := ListFloorBySubjectReqValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectReqMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectReqMultiError is an error wrapping multiple validation
// errors returned by ListFloorBySubjectReq.ValidateAll() if the designated
// constraints aren't met.
type ListFloorBySubjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectReqMultiError) AllErrors() []error { return m }

// ListFloorBySubjectReqValidationError is the validation error returned by
// ListFloorBySubjectReq.Validate if the designated constraints aren't met.
type ListFloorBySubjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectReqValidationError) ErrorName() string {
	return "ListFloorBySubjectReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectReqValidationError{}

// Validate checks the field values on ListFloorBySubjectResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListFloorBySubjectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectResponseMultiError, or nil if none found.
func (m *ListFloorBySubjectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectResponseMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectResponseMultiError is an error wrapping multiple
// validation errors returned by ListFloorBySubjectResponse.ValidateAll() if
// the designated constraints aren't met.
type ListFloorBySubjectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectResponseMultiError) AllErrors() []error { return m }

// ListFloorBySubjectResponseValidationError is the validation error returned
// by ListFloorBySubjectResponse.Validate if the designated constraints aren't met.
type ListFloorBySubjectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectResponseValidationError) ErrorName() string {
	return "ListFloorBySubjectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectResponseValidationError{}

// Validate checks the field values on ListReplyByFloorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByFloorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReplyByFloorReqMultiError, or nil if none found.
func (m *ListReplyByFloorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubjectId() < 0 {
		err := ListReplyByFloorReqValidationError{
			field:  "SubjectId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFloorId() < 0 {
		err := ListReplyByFloorReqValidationError{
			field:  "FloorId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorReqValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorReqValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorReqMultiError(errors)
	}

	return nil
}

// ListReplyByFloorReqMultiError is an error wrapping multiple validation
// errors returned by ListReplyByFloorReq.ValidateAll() if the designated
// constraints aren't met.
type ListReplyByFloorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorReqMultiError) AllErrors() []error { return m }

// ListReplyByFloorReqValidationError is the validation error returned by
// ListReplyByFloorReq.Validate if the designated constraints aren't met.
type ListReplyByFloorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorReqValidationError) ErrorName() string {
	return "ListReplyByFloorReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorReqValidationError{}

// Validate checks the field values on ListReplyByFloorResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByFloorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReplyByFloorResponseMultiError, or nil if none found.
func (m *ListReplyByFloorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorResponseMultiError(errors)
	}

	return nil
}

// ListReplyByFloorResponseMultiError is an error wrapping multiple validation
// errors returned by ListReplyByFloorResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReplyByFloorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorResponseMultiError) AllErrors() []error { return m }

// ListReplyByFloorResponseValidationError is the validation error returned by
// ListReplyByFloorResponse.Validate if the designated constraints aren't met.
type ListReplyByFloorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorResponseValidationError) ErrorName() string {
	return "ListReplyByFloorResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorResponseValidationError{}

// Validate checks the field values on AddLikeReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddLikeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddLikeReqMultiError, or
// nil if none found.
func (m *AddLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetReplyId() < 0 {
		err := AddLikeReqValidationError{
			field:  "ReplyId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Uid

	if len(errors) > 0 {
		return AddLikeReqMultiError(errors)
	}

	return nil
}

// AddLikeReqMultiError is an error wrapping multiple validation errors
// returned by AddLikeReq.ValidateAll() if the designated constraints aren't met.
type AddLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddLikeReqMultiError) AllErrors() []error { return m }

// AddLikeReqValidationError is the validation error returned by
// AddLikeReq.Validate if the designated constraints aren't met.
type AddLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddLikeReqValidationError) ErrorName() string { return "AddLikeReqValidationError" }

// Error satisfies the builtin error interface
func (e AddLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddLikeReqValidationError{}

// Validate checks the field values on AddLikeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddLikeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddLikeResponseMultiError, or nil if none found.
func (m *AddLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddLikeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddLikeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddLikeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddLikeResponseMultiError(errors)
	}

	return nil
}

// AddLikeResponseMultiError is an error wrapping multiple validation errors
// returned by AddLikeResponse.ValidateAll() if the designated constraints
// aren't met.
type AddLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddLikeResponseMultiError) AllErrors() []error { return m }

// AddLikeResponseValidationError is the validation error returned by
// AddLikeResponse.Validate if the designated constraints aren't met.
type AddLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddLikeResponseValidationError) ErrorName() string { return "AddLikeResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddLikeResponseValidationError{}

// Validate checks the field values on CancelLikeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CancelLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLikeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CancelLikeReqMultiError, or
// nil if none found.
func (m *CancelLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetReplyId() < 0 {
		err := CancelLikeReqValidationError{
			field:  "ReplyId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Uid

	if len(errors) > 0 {
		return CancelLikeReqMultiError(errors)
	}

	return nil
}

// CancelLikeReqMultiError is an error wrapping multiple validation errors
// returned by CancelLikeReq.ValidateAll() if the designated constraints
// aren't met.
type CancelLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLikeReqMultiError) AllErrors() []error { return m }

// CancelLikeReqValidationError is the validation error returned by
// CancelLikeReq.Validate if the designated constraints aren't met.
type CancelLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLikeReqValidationError) ErrorName() string { return "CancelLikeReqValidationError" }

// Error satisfies the builtin error interface
func (e CancelLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLikeReqValidationError{}

// Validate checks the field values on CancelLikeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLikeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLikeResponseMultiError, or nil if none found.
func (m *CancelLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelLikeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelLikeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelLikeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelLikeResponseMultiError(errors)
	}

	return nil
}

// CancelLikeResponseMultiError is an error wrapping multiple validation errors
// returned by CancelLikeResponse.ValidateAll() if the designated constraints
// aren't met.
type CancelLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLikeResponseMultiError) AllErrors() []error { return m }

// CancelLikeResponseValidationError is the validation error returned by
// CancelLikeResponse.Validate if the designated constraints aren't met.
type CancelLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLikeResponseValidationError) ErrorName() string {
	return "CancelLikeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLikeResponseValidationError{}

// Validate checks the field values on IsLikeReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IsLikeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsLikeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IsLikeReqMultiError, or nil
// if none found.
func (m *IsLikeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *IsLikeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetReplyId() < 0 {
		err := IsLikeReqValidationError{
			field:  "ReplyId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Uid

	if len(errors) > 0 {
		return IsLikeReqMultiError(errors)
	}

	return nil
}

// IsLikeReqMultiError is an error wrapping multiple validation errors returned
// by IsLikeReq.ValidateAll() if the designated constraints aren't met.
type IsLikeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsLikeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsLikeReqMultiError) AllErrors() []error { return m }

// IsLikeReqValidationError is the validation error returned by
// IsLikeReq.Validate if the designated constraints aren't met.
type IsLikeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsLikeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsLikeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsLikeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsLikeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsLikeReqValidationError) ErrorName() string { return "IsLikeReqValidationError" }

// Error satisfies the builtin error interface
func (e IsLikeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsLikeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsLikeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsLikeReqValidationError{}

// Validate checks the field values on IsLikeResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IsLikeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsLikeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IsLikeResponseMultiError,
// or nil if none found.
func (m *IsLikeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsLikeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IsLikeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IsLikeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IsLikeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IsLikeResponseMultiError(errors)
	}

	return nil
}

// IsLikeResponseMultiError is an error wrapping multiple validation errors
// returned by IsLikeResponse.ValidateAll() if the designated constraints
// aren't met.
type IsLikeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsLikeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsLikeResponseMultiError) AllErrors() []error { return m }

// IsLikeResponseValidationError is the validation error returned by
// IsLikeResponse.Validate if the designated constraints aren't met.
type IsLikeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsLikeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsLikeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsLikeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsLikeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsLikeResponseValidationError) ErrorName() string { return "IsLikeResponseValidationError" }

// Error satisfies the builtin error interface
func (e IsLikeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsLikeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsLikeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsLikeResponseValidationError{}

// Validate checks the field values on CreateSubjectResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubjectResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubjectResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubjectResponse_DataMultiError, or nil if none found.
func (m *CreateSubjectResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubjectResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	if len(errors) > 0 {
		return CreateSubjectResponse_DataMultiError(errors)
	}

	return nil
}

// CreateSubjectResponse_DataMultiError is an error wrapping multiple
// validation errors returned by CreateSubjectResponse_Data.ValidateAll() if
// the designated constraints aren't met.
type CreateSubjectResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubjectResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubjectResponse_DataMultiError) AllErrors() []error { return m }

// CreateSubjectResponse_DataValidationError is the validation error returned
// by CreateSubjectResponse_Data.Validate if the designated constraints aren't met.
type CreateSubjectResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubjectResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubjectResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubjectResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubjectResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubjectResponse_DataValidationError) ErrorName() string {
	return "CreateSubjectResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubjectResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubjectResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubjectResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubjectResponse_DataValidationError{}

// Validate checks the field values on GetSubjectByIdResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByIdResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByIdResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubjectByIdResponse_DataMultiError, or nil if none found.
func (m *GetSubjectByIdResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByIdResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubjectByIdResponse_DataValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubjectByIdResponse_DataValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubjectByIdResponse_DataValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubjectByIdResponse_DataMultiError(errors)
	}

	return nil
}

// GetSubjectByIdResponse_DataMultiError is an error wrapping multiple
// validation errors returned by GetSubjectByIdResponse_Data.ValidateAll() if
// the designated constraints aren't met.
type GetSubjectByIdResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByIdResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByIdResponse_DataMultiError) AllErrors() []error { return m }

// GetSubjectByIdResponse_DataValidationError is the validation error returned
// by GetSubjectByIdResponse_Data.Validate if the designated constraints
// aren't met.
type GetSubjectByIdResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByIdResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByIdResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByIdResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByIdResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByIdResponse_DataValidationError) ErrorName() string {
	return "GetSubjectByIdResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByIdResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByIdResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByIdResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByIdResponse_DataValidationError{}

// Validate checks the field values on GetSubjectByBelongResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubjectByBelongResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubjectByBelongResponse_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSubjectByBelongResponse_DataMultiError, or nil if none found.
func (m *GetSubjectByBelongResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubjectByBelongResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubjectByBelongResponse_DataValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubjectByBelongResponse_DataValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubjectByBelongResponse_DataValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubjectByBelongResponse_DataMultiError(errors)
	}

	return nil
}

// GetSubjectByBelongResponse_DataMultiError is an error wrapping multiple
// validation errors returned by GetSubjectByBelongResponse_Data.ValidateAll()
// if the designated constraints aren't met.
type GetSubjectByBelongResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubjectByBelongResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubjectByBelongResponse_DataMultiError) AllErrors() []error { return m }

// GetSubjectByBelongResponse_DataValidationError is the validation error
// returned by GetSubjectByBelongResponse_Data.Validate if the designated
// constraints aren't met.
type GetSubjectByBelongResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubjectByBelongResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubjectByBelongResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubjectByBelongResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubjectByBelongResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubjectByBelongResponse_DataValidationError) ErrorName() string {
	return "GetSubjectByBelongResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubjectByBelongResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubjectByBelongResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubjectByBelongResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubjectByBelongResponse_DataValidationError{}

// Validate checks the field values on CreateReplyResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReplyResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReplyResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateReplyResponse_DataMultiError, or nil if none found.
func (m *CreateReplyResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReplyResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReplyId

	if len(errors) > 0 {
		return CreateReplyResponse_DataMultiError(errors)
	}

	return nil
}

// CreateReplyResponse_DataMultiError is an error wrapping multiple validation
// errors returned by CreateReplyResponse_Data.ValidateAll() if the designated
// constraints aren't met.
type CreateReplyResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReplyResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReplyResponse_DataMultiError) AllErrors() []error { return m }

// CreateReplyResponse_DataValidationError is the validation error returned by
// CreateReplyResponse_Data.Validate if the designated constraints aren't met.
type CreateReplyResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReplyResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReplyResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReplyResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReplyResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReplyResponse_DataValidationError) ErrorName() string {
	return "CreateReplyResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReplyResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReplyResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReplyResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReplyResponse_DataValidationError{}

// Validate checks the field values on ListFloorBySubjectResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListFloorBySubjectResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFloorBySubjectResponse_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListFloorBySubjectResponse_DataMultiError, or nil if none found.
func (m *ListFloorBySubjectResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFloorBySubjectResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFloors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFloorBySubjectResponse_DataValidationError{
						field:  fmt.Sprintf("Floors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFloorBySubjectResponse_DataValidationError{
						field:  fmt.Sprintf("Floors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFloorBySubjectResponse_DataValidationError{
					field:  fmt.Sprintf("Floors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFloorBySubjectResponse_DataValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFloorBySubjectResponse_DataValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFloorBySubjectResponse_DataValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListFloorBySubjectResponse_DataMultiError(errors)
	}

	return nil
}

// ListFloorBySubjectResponse_DataMultiError is an error wrapping multiple
// validation errors returned by ListFloorBySubjectResponse_Data.ValidateAll()
// if the designated constraints aren't met.
type ListFloorBySubjectResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFloorBySubjectResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFloorBySubjectResponse_DataMultiError) AllErrors() []error { return m }

// ListFloorBySubjectResponse_DataValidationError is the validation error
// returned by ListFloorBySubjectResponse_Data.Validate if the designated
// constraints aren't met.
type ListFloorBySubjectResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFloorBySubjectResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFloorBySubjectResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFloorBySubjectResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFloorBySubjectResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFloorBySubjectResponse_DataValidationError) ErrorName() string {
	return "ListFloorBySubjectResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ListFloorBySubjectResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFloorBySubjectResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFloorBySubjectResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFloorBySubjectResponse_DataValidationError{}

// Validate checks the field values on ListReplyByFloorResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReplyByFloorResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReplyByFloorResponse_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListReplyByFloorResponse_DataMultiError, or nil if none found.
func (m *ListReplyByFloorResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReplyByFloorResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReplyByFloorResponse_DataValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReplyByFloorResponse_DataValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReplyByFloorResponse_DataValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReplyByFloorResponse_DataValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReplyByFloorResponse_DataValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReplyByFloorResponse_DataValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListReplyByFloorResponse_DataMultiError(errors)
	}

	return nil
}

// ListReplyByFloorResponse_DataMultiError is an error wrapping multiple
// validation errors returned by ListReplyByFloorResponse_Data.ValidateAll()
// if the designated constraints aren't met.
type ListReplyByFloorResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReplyByFloorResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReplyByFloorResponse_DataMultiError) AllErrors() []error { return m }

// ListReplyByFloorResponse_DataValidationError is the validation error
// returned by ListReplyByFloorResponse_Data.Validate if the designated
// constraints aren't met.
type ListReplyByFloorResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReplyByFloorResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReplyByFloorResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReplyByFloorResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReplyByFloorResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReplyByFloorResponse_DataValidationError) ErrorName() string {
	return "ListReplyByFloorResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ListReplyByFloorResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReplyByFloorResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReplyByFloorResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReplyByFloorResponse_DataValidationError{}

// Validate checks the field values on AddLikeResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddLikeResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddLikeResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddLikeResponse_DataMultiError, or nil if none found.
func (m *AddLikeResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *AddLikeResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddLikeResponse_DataMultiError(errors)
	}

	return nil
}

// AddLikeResponse_DataMultiError is an error wrapping multiple validation
// errors returned by AddLikeResponse_Data.ValidateAll() if the designated
// constraints aren't met.
type AddLikeResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddLikeResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddLikeResponse_DataMultiError) AllErrors() []error { return m }

// AddLikeResponse_DataValidationError is the validation error returned by
// AddLikeResponse_Data.Validate if the designated constraints aren't met.
type AddLikeResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddLikeResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddLikeResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddLikeResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddLikeResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddLikeResponse_DataValidationError) ErrorName() string {
	return "AddLikeResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e AddLikeResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddLikeResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddLikeResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddLikeResponse_DataValidationError{}

// Validate checks the field values on CancelLikeResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLikeResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLikeResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLikeResponse_DataMultiError, or nil if none found.
func (m *CancelLikeResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLikeResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CancelLikeResponse_DataMultiError(errors)
	}

	return nil
}

// CancelLikeResponse_DataMultiError is an error wrapping multiple validation
// errors returned by CancelLikeResponse_Data.ValidateAll() if the designated
// constraints aren't met.
type CancelLikeResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLikeResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLikeResponse_DataMultiError) AllErrors() []error { return m }

// CancelLikeResponse_DataValidationError is the validation error returned by
// CancelLikeResponse_Data.Validate if the designated constraints aren't met.
type CancelLikeResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLikeResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLikeResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLikeResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLikeResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLikeResponse_DataValidationError) ErrorName() string {
	return "CancelLikeResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLikeResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLikeResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLikeResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLikeResponse_DataValidationError{}

// Validate checks the field values on IsLikeResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IsLikeResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsLikeResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsLikeResponse_DataMultiError, or nil if none found.
func (m *IsLikeResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *IsLikeResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return IsLikeResponse_DataMultiError(errors)
	}

	return nil
}

// IsLikeResponse_DataMultiError is an error wrapping multiple validation
// errors returned by IsLikeResponse_Data.ValidateAll() if the designated
// constraints aren't met.
type IsLikeResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsLikeResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsLikeResponse_DataMultiError) AllErrors() []error { return m }

// IsLikeResponse_DataValidationError is the validation error returned by
// IsLikeResponse_Data.Validate if the designated constraints aren't met.
type IsLikeResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsLikeResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsLikeResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsLikeResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsLikeResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsLikeResponse_DataValidationError) ErrorName() string {
	return "IsLikeResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e IsLikeResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsLikeResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsLikeResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsLikeResponse_DataValidationError{}
